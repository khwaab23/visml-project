<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile Metrics Visualization | ML Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Portfolio Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /*
        ==========================================
        PORTFOLIO THEME INTEGRATION
        ==========================================
        Source: Portfolio-Final project (khwaabportfolio.netlify.app)
        
        Theme Mapping:
        - Portfolio body background → Dashboard main background
        - Portfolio card-project → Dashboard visualization cards
        - Portfolio gradient-text → Dashboard section titles
        - Portfolio btn-secondary → Dashboard control buttons
        - Portfolio glass-effect → Dashboard containers
        - Portfolio shadow-card → Dashboard card shadows
        - Portfolio hover-lift → Dashboard interactive elements
        
        All dashboard IDs preserved for JS functionality.
        */
        
        /* =========================
           PORTFOLIO CSS VARIABLES
           ========================= */
        :root {
            /* Fonts */
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            
            /* Font Sizes */
            --text-7xl: 4.5rem;
            --text-5xl: 3rem;
            --text-4xl: 2.25rem;
            --text-3xl: 1.875rem;
            --text-2xl: 1.5rem;
            --text-xl: 1.25rem;
            --text-lg: 1.125rem;
            --text-base: 1rem;
            --text-sm: 0.875rem;
            --text-xs: 0.75rem;
            
            /* Font Weights */
            --font-normal: 400;
            --font-medium: 500;
            --font-semibold: 600;
            --font-bold: 700;
            
            /* Line Heights */
            --leading-tight: 1.2;
            --leading-normal: 1.5;
            --leading-relaxed: 1.75;
            
            /* Colors - Indigo */
            --color-indigo-600: #4f46e5;
            --color-indigo-500: #6366f1;
            --color-indigo-400: #818cf8;
            --color-indigo-300: #a5b4fc;
            --color-indigo-200: #c7d2fe;
            
            /* Colors - Gray Scale */
            --color-gray-950: #0a0a0f;
            --color-gray-900: #111827;
            --color-gray-800: #1f2937;
            --color-gray-700: #374151;
            --color-gray-600: #4b5563;
            --color-gray-500: #6b7280;
            --color-gray-400: #9ca3af;
            --color-gray-300: #d1d5db;
            --color-gray-200: #e5e7eb;
            --color-gray-50: #f9fafb;
            --color-white: #ffffff;
            
            /* Semantic Colors */
            --bg-primary: #0a0a0f;
            --bg-secondary: #111827;
            --bg-card: #1f2937;
            --bg-card-hover: #374151;
            --bg-header: rgba(31, 41, 55, 0.5);
            
            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: rgba(199, 210, 254, 0.65);
            --text-muted: rgba(199, 210, 254, 0.50);
            --text-accent: #c7d2fe;
            --text-heading: #a5b4fc;
            
            /* Border Colors */
            --border-primary: rgba(75, 85, 99, 0.5);
            --border-secondary: rgba(148, 163, 184, 0.25);
            --border-accent: rgba(99, 102, 241, 0.3);
            
            /* Gradients */
            --gradient-text-primary: linear-gradient(to right, #6366f1, #c7d2fe);
            --gradient-text-section: linear-gradient(to right, #e5e7eb, #c7d2fe, #f9fafb, #a5b4fc, #e5e7eb);
            --gradient-bg-card: linear-gradient(to bottom right, rgba(17, 24, 39, 0.5), rgba(31, 41, 55, 0.25), rgba(17, 24, 39, 0.5));
            --gradient-button-primary: linear-gradient(to top, #4f46e5, #6366f1);
            --gradient-button-secondary: linear-gradient(to bottom, #1f2937, rgba(31, 41, 55, 0.6));
            
            /* Spacing */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            --space-3xl: 4rem;
            
            /* Border Radius */
            --radius-xs: 0.25rem;
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
        }
        
        /* =========================
           PORTFOLIO ANIMATIONS
           ========================= */
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* =========================
           BASE STYLES
           ========================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 0;
            margin: 0;
            line-height: var(--leading-normal);
            position: relative;
            overflow-x: hidden;
        }

        /* =========================
           PORTFOLIO UTILITY CLASSES
           ========================= */
        .gradient-text {
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .gradient-text-section {
            background: var(--gradient-text-section);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 10s linear infinite;
        }
        
        .glass-effect {
            background: rgba(31, 41, 55, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .card-base {
            position: relative;
            border-radius: var(--radius-lg);
            background: var(--gradient-bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .card-base:hover {
            border-color: var(--border-accent);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.8),
                0 0 0 1px rgba(99, 102, 241, 0.3);
        }
        
        .hover-lift {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .hover-lift:hover {
            transform: translateY(-2px);
        }
        
        /* =========================
           CONTAINER & LAYOUT (Legacy - now using app-shell)
           ========================= */
        .container {
            /* Deprecated: Now using .app-shell layout */
        }

        /* Header (Legacy - now in topbar) */
        .header {
            /* Deprecated: Now using .app-topbar */
        }

        .header h1 {
            /* Deprecated: Now using .topbar-title */
        }

        .header p {
            /* Deprecated: Now using .topbar-info */
        }

        .icon {
            width: 32px;
            height: 32px;
            display: inline-block;
        }

        /* =========================
           STATS GRID (Portfolio Card Style)
           ========================= */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-2xl);
        }

        .stat-card {
            position: relative;
            background: var(--gradient-bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--gradient-text-primary);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .stat-card:hover {
            border-color: var(--border-accent);
            transform: translateY(-4px);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.6),
                0 0 20px rgba(99, 102, 241, 0.3);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-label {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
            font-size: var(--text-sm);
            color: var(--text-accent);
            font-weight: var(--font-medium);
        }

        .stat-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 8px currentColor;
        }

        .stat-value {
            font-size: var(--text-3xl);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: var(--space-sm);
        }

        .stat-sparkline {
            margin: var(--space-md) 0 var(--space-sm) 0;
            display: flex;
            justify-content: center;
        }

        .stat-range {
            font-size: var(--text-xs);
            color: var(--text-muted);
        }

        /* =========================
           CONTROLS PANEL (Portfolio Glass Effect)
           ========================= */
        .controls {
            background: rgba(31, 41, 55, 0.5);
            backdrop-filter: blur(16px);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            margin-bottom: var(--space-2xl);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-lg);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            font-family: var(--font-primary);
            color: var(--text-accent);
            margin-bottom: var(--space-sm);
        }

        /* Portfolio Button Styles */
        select, input[type="range"] {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-md);
            padding: var(--space-sm) var(--space-md);
            font-size: var(--text-sm);
            font-family: var(--font-body);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        select:hover {
            border-color: var(--border-accent);
            background: var(--bg-card-hover);
        }

        select:focus, input[type="range"]:focus {
            outline: none;
            border-color: var(--color-indigo-500);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .range-value {
            font-size: var(--text-xs);
            color: var(--text-muted);
            margin-top: var(--space-xs);
            font-weight: var(--font-medium);
        }

        /* =========================
           VISUALIZATION CARDS (Portfolio Style)
           ========================= */
        .visualization {
            position: relative;
            background: var(--gradient-bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            margin-bottom: var(--space-2xl);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .visualization:hover {
            border-color: var(--border-accent);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.6),
                0 0 20px rgba(99, 102, 241, 0.2);
        }

        .vis-title {
            font-family: var(--font-primary);
            font-weight: var(--font-semibold);
            font-size: var(--text-xl);
            margin-bottom: var(--space-lg);
            display: flex;
            align-items: center;
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            gap: 8px;
        }

        /* Heatmap */
        .heatmap-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px auto;
            max-width: fit-content;
        }

        .heatmap-main {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 0;
        }

        .heatmap-axis-label-y {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            padding: 0 10px;
            text-align: center;
        }

        .heatmap-axis-label-x {
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            padding: 10px 0;
            text-align: center;
        }

        .heatmap-container {
            overflow: visible;
            margin-bottom: 0;
            display: flex;
            justify-content: center;
        }

        .heatmap-grid {
            display: inline-grid;
            gap: 2px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }

        /* =========================
           HEATMAP CELLS (Portfolio Enhanced)
           ========================= */
        .heatmap-cell {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-md);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            font-family: var(--font-body);
            color: var(--color-white);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            border: 1px solid rgba(99, 102, 241, 0.1);
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5),
                        0 0 12px rgba(99, 102, 241, 0.4);
            border-color: var(--border-accent);
        }

        .heatmap-cell.empty {
            background: rgba(17, 24, 39, 0.4);
            cursor: default;
            border-color: var(--border-primary);
        }

        .heatmap-cell.empty:hover {
            transform: scale(1);
            box-shadow: none;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        .tooltip.show {
            display: block;
        }

        /* Legend */
        .legend {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
            padding: 12px;
            font-size: 13px;
            font-weight: 500;
            color: #cbd5e1;
        }

        /* =========================
           LEGEND & SCALE BARS (Portfolio Style)
           ========================= */
        .legend-bar {
            height: 18px;
            width: 240px;
            border-radius: var(--radius-md);
            background: linear-gradient(to right, 
                rgb(120, 40, 35),
                rgb(160, 120, 35),
                rgb(70, 140, 50));
            border: 1px solid var(--border-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* =========================
           GLOBAL CONFUSION MATRIX (Hero Card)
           ========================= */
        .global-confusion-matrix {
            margin-bottom: var(--space-3xl);
            padding: var(--space-2xl);
            background: var(--gradient-bg-card);
            backdrop-filter: blur(16px);
            border: 1px solid var(--border-accent);
            border-radius: var(--radius-xl);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(99, 102, 241, 0.3);
            position: relative;
            overflow: hidden;
        }

        .global-confusion-matrix::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-text-primary);
        }

        .global-confusion-matrix h2 {
            font-size: var(--text-2xl);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            margin-bottom: var(--space-xl);
            text-align: center;
            background: var(--gradient-text-section);
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 6s linear infinite;
        }

        .cm-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            max-width: 700px;
            margin: 0 auto;
        }

        .cm-cell {
            padding: var(--space-2xl);
            border-radius: var(--radius-lg);
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }

        .cm-cell:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
        }

        .cm-cell.tp {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.5);
        }

        .cm-cell.tp:hover {
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
        }

        .cm-cell.fp {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .cm-cell.fp:hover {
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
        }

        .cm-cell.fn {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.5);
        }

        .cm-cell.fn:hover {
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.4);
        }

        .cm-cell.total {
            background: rgba(99, 102, 241, 0.15);
            border-color: rgba(99, 102, 241, 0.5);
        }

        .cm-cell.total:hover {
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
        }

        .cm-cell h3 {
            margin: 0 0 var(--space-md) 0;
            font-size: var(--text-sm);
            font-family: var(--font-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.9;
            color: #cbd5e1;
        }

        .cm-cell .value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 6px;
            color: #f1f5f9;
        }

        .cm-cell .percentage {
            font-size: 16px;
            opacity: 0.75;
            color: #94a3b8;
        }

        /* Table */
        .global-confusion-matrix {
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid #334155;
            border-radius: 12px;
        }

        .global-confusion-matrix h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #f1f5f9;
            text-align: center;
        }

        .cm-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            max-width: 700px;
            margin: 0 auto;
        }

        .cm-cell {
            padding: 24px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .cm-cell:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .cm-cell.tp {
            background: rgba(76, 175, 80, 0.2);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .cm-cell.fp {
            background: rgba(244, 67, 54, 0.2);
            border-color: rgba(244, 67, 54, 0.5);
        }

        .cm-cell.fn {
            background: rgba(255, 152, 0, 0.2);
            border-color: rgba(255, 152, 0, 0.5);
        }

        .cm-cell.total {
            background: rgba(148, 163, 184, 0.15);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .cm-cell h3 {
            margin: 0 0 12px 0;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.9;
            color: #cbd5e1;
        }

        .cm-cell .value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 6px;
            color: #f1f5f9;
        }

        .cm-cell .percentage {
            font-size: 16px;
            opacity: 0.75;
            color: #94a3b8;
        }

        /* Distributions / Boxplots */
        .boxplot-row {
            margin-bottom: 20px;
        }

        .boxplot-label {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .boxplot-svg {
            display: block;
            margin: 0 auto;
        }

        /* Composition Stacked Bars */
        .composition-bar-row {
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .composition-label {
            width: 140px;
            font-size: 11px;
            color: #94a3b8;
            text-align: right;
            flex-shrink: 0;
        }

        .composition-bar {
            flex: 1;
            height: 24px;
            display: flex;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #334155;
            position: relative;
        }

        .composition-segment {
            height: 100%;
            transition: opacity 0.2s;
            cursor: pointer;
            position: relative;
        }

        .composition-segment:hover {
            opacity: 0.8;
        }

        .composition-segment.tp {
            background: #10b981;
        }

        .composition-segment.fp {
            background: #ef4444;
        }

        .composition-segment.fn {
            background: #f59e0b;
        }

        .composition-value {
            width: 80px;
            font-size: 11px;
            color: #cbd5e1;
            text-align: left;
            flex-shrink: 0;
        }

        /* Correlation Heatmap */
        .correlation-grid {
            display: inline-grid;
            gap: 2px;
            background: #1e293b;
            padding: 2px;
            border-radius: 8px;
        }

        .correlation-cell {
            width: 70px;
            height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .correlation-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .correlation-cell.header {
            background: #1e293b;
            color: #94a3b8;
            font-size: 10px;
            font-weight: 700;
            cursor: default;
            text-align: center;
            line-height: 1.2;
        }

        .correlation-cell.header:hover {
            transform: none;
            box-shadow: none;
        }

        .correlation-value {
            font-size: 14px;
            margin-top: 4px;
        }

        /* Performance Buckets */
        .buckets-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* =========================
           BUCKET CARDS (Portfolio Style)
           ========================= */
        .bucket-card {
            background: var(--gradient-bg-card);
            backdrop-filter: blur(12px);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }

        .bucket-card:hover {
            border-color: var(--border-accent);
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.6),
                        0 0 20px rgba(99, 102, 241, 0.25);
        }

        .bucket-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--border-primary);
        }

        .bucket-title {
            font-size: var(--text-lg);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            color: var(--text-primary);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .bucket-count {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            background: rgba(99, 102, 241, 0.15);
            padding: var(--space-xs) var(--space-md);
            border-radius: var(--radius-full);
            border: 1px solid var(--border-accent);
        }

        .bucket-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 3px;
            margin-bottom: 10px;
        }

        .bucket-cell {
            aspect-ratio: 1;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: rgba(255, 255, 255, 0.4);
        }

        .bucket-cell:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .bucket-cell.empty {
            background: rgba(255, 255, 255, 0.02);
            cursor: default;
        }

        .bucket-cell.empty:hover {
            transform: none;
            box-shadow: none;
        }

        .bucket-map-container {
            width: 100%;
            aspect-ratio: 12 / 8; /* Match grid's 12 columns x 8 rows */
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .bucket-toggle {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 10px;
            background: rgba(30, 41, 59, 0.5);
            padding: 4px;
            border-radius: 6px;
        }

        .bucket-toggle-btn {
            flex: 1;
            padding: 4px 8px;
            background: transparent;
            color: #94a3b8;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .bucket-toggle-btn.active {
            background: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        .bucket-stats {
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            color: #94a3b8;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .bucket-stat {
            text-align: center;
        }

        .bucket-stat-value {
            display: block;
            font-size: 16px;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 2px;
        }

        /* Table */
        /* =========================
           TABLE SECTION (Portfolio Style)
           ========================= */
        .table-container {
            overflow-x: auto;
            max-height: 600px;
            background: var(--gradient-bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-lg);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--text-xs);
            font-family: var(--font-body);
        }

        thead {
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, var(--bg-card), var(--bg-secondary));
            border-bottom: 2px solid var(--border-accent);
            z-index: 10;
        }

        th {
            padding: var(--space-md) var(--space-sm);
            text-align: left;
            color: var(--text-primary);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            font-size: var(--text-sm);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        td {
            padding: var(--space-md) var(--space-sm);
            border-bottom: 1px solid var(--border-primary);
            color: var(--text-secondary);
        }

        tbody tr {
            transition: all 0.2s ease;
        }

        tbody tr:hover {
            background: rgba(99, 102, 241, 0.1);
            transform: scale(1.002);
        }

        tbody tr:nth-child(even) {
            background: rgba(17, 24, 39, 0.4);
        }

        .metric-good { color: #4ade80; font-weight: var(--font-medium); }
        .metric-okay { color: #facc15; font-weight: var(--font-medium); }
        .metric-bad { color: #f87171; font-weight: var(--font-medium); }

        .metric-tp { color: #2dd4bf; font-weight: var(--font-medium); }
        .metric-fp { color: #f87171; font-weight: var(--font-medium); }
        .metric-fn { color: #fbbf24; font-weight: var(--font-medium); }

        /* Back Button */
        /* =========================
           BUTTONS (Portfolio Style)
           ========================= */
        .back-btn {
            display: inline-block;
            padding: var(--space-sm) var(--space-lg);
            background: var(--gradient-button-primary);
            color: var(--color-white);
            text-decoration: none;
            border-radius: var(--radius-full);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            font-family: var(--font-primary);
            margin-bottom: var(--space-xl);
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .back-btn:hover {
            background: var(--color-indigo-600);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5);
        }

        /* Parallel Coordinates Styles */
        .parallel-axis {
            stroke: #64748b;
            stroke-width: 2;
        }

        /* =========================
           PARALLEL COORDINATES (Portfolio Colors)
           ========================= */
        .parallel-line {
            fill: none;
            stroke-width: 1.5;
            opacity: 0.5;
            transition: all 0.2s ease;
        }

        .parallel-line:hover {
            opacity: 1;
            stroke-width: 3;
            filter: drop-shadow(0 0 4px currentColor);
        }

        .parallel-line.highlighted {
            stroke: var(--color-indigo-400) !important;
            stroke-width: 3;
            opacity: 1;
            filter: drop-shadow(0 0 8px var(--color-indigo-400));
        }

        .parallel-line.dimmed {
            opacity: 0.15;
        }

        /* Tile Filter Dropdown Styles */
        .tile-filter-container {
            position: relative;
            display: inline-block;
        }

        .tile-filter-dropdown-btn {
            padding: 8px 16px;
            background: rgba(59, 130, 246, 0.2);
            color: #e2e8f0;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .tile-filter-dropdown-btn:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .tile-filter-dropdown-btn::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s;
        }

        .tile-filter-dropdown-btn.open::after {
            transform: rotate(180deg);
        }

        .tile-checkboxes {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .tile-checkboxes.open {
            display: block;
        }

        .tile-checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(30, 41, 59, 0.5);
        }

        .tile-checkbox-item:last-child {
            border-bottom: none;
        }

        .tile-checkbox-item:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .tile-checkbox-item.select-all {
            background: rgba(30, 41, 59, 0.8);
            border-bottom: 2px solid rgba(59, 130, 246, 0.4);
            font-weight: 500;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .tile-checkbox-item input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .tile-checkbox-item label {
            cursor: pointer;
            font-size: 12px;
            color: #cbd5e1;
            user-select: none;
            flex: 1;
        }

        .tile-checkbox-item.select-all label {
            font-weight: 600;
            color: #e2e8f0;
        }

        .tile-checkbox-item input[type="checkbox"]:checked + label {
            color: #60a5fa;
            font-weight: 500;
        }

        .tile-search-input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 4px;
            color: #e2e8f0;
            font-size: 12px;
            outline: none;
            box-sizing: border-box;
        }

        .tile-search-input:focus {
            border-color: rgba(59, 130, 246, 0.6);
            background: rgba(30, 41, 59, 0.95);
        }

        .tile-search-input::placeholder {
            color: #64748b;
        }

        .tile-search-container {
            padding: 10px;
            background: rgba(30, 41, 59, 0.8);
            border-bottom: 2px solid rgba(59, 130, 246, 0.4);
            position: sticky;
            top: 0;
            z-index: 2;
        }

        .loading {
            text-align: center;
            padding: 48px 24px;
            color: #94a3b8;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 6px;
            padding: 16px;
            color: #fca5a5;
            margin: 16px 0;
        }

        /* ============================================== */
        /* TILE DETAIL MODAL STYLES (Feature #8)        */
        /* ============================================== */

        /* =========================
           TILE DETAIL MODAL (Portfolio Glass Card)
           ========================= */
        .modal-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.85);
            z-index: 9998;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .modal-backdrop.visible {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tile-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            background: var(--gradient-bg-card);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: var(--radius-xl);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.8),
                0 0 40px rgba(99, 102, 241, 0.4);
            border: 1px solid var(--border-accent);
            z-index: 9999;
            overflow-y: auto;
        }

        .tile-modal.visible {
            display: block;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -45%) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xl) var(--space-2xl);
            border-bottom: 1px solid var(--border-primary);
            background: rgba(17, 24, 39, 0.6);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            position: relative;
        }

        .modal-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--gradient-text-primary);
            opacity: 0.3;
        }

        .modal-header h2 {
            margin: 0;
            font-size: var(--text-xl);
            font-family: var(--font-primary);
            font-weight: var(--font-semibold);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-close {
            background: rgba(31, 41, 55, 0.6);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 36px;
            height: 36px;
            border-radius: var(--radius-md);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: var(--color-indigo-600);
            border-color: var(--color-indigo-500);
            color: var(--color-white);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
        }

        .modal-body {
            padding: var(--space-2xl);
        }

        .modal-section {
            margin-bottom: var(--space-xl);
            padding: var(--space-lg);
            background: rgba(17, 24, 39, 0.4);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }

        .modal-section:hover {
            border-color: var(--border-accent);
            background: rgba(17, 24, 39, 0.6);
        }

        .modal-section h3 {
            margin: 0 0 var(--space-md) 0;
            font-size: var(--text-lg);
            font-family: var(--font-primary);
            font-weight: var(--font-semibold);
            color: var(--text-accent);
        }

        .modal-section h4 {
            margin: 0 0 var(--space-sm) 0;
            font-size: var(--text-base);
            font-family: var(--font-primary);
            color: var(--text-secondary);
            font-weight: var(--font-medium);
        }

        #tile-mini-map {
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        /* =========================
           PORTFOLIO BACKGROUND GRAPHICS
           ========================= */
        .bg-illustration {
            pointer-events: none;
            position: fixed;
            z-index: 0;
        }

        .bg-illustration img {
            max-width: none;
            width: 100vw;
            height: auto;
        }

        .hero-illustration {
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }

        .hero-illustration img {
            width: 1600px;
            max-width: none;
        }

        .secondary-illustration {
            left: 50%;
            top: 30%;
            transform: translateX(-50%);
            opacity: 0.5;
        }

        .secondary-illustration img {
            width: 800px;
            max-width: none;
        }

        .blurred-shape {
            filter: blur(60px);
            opacity: 0.3;
        }

        .blurred-shape img {
            width: 400px;
            max-width: none;
        }

        .blurred-shape-1 {
            left: 5%;
            top: 25%;
        }

        .blurred-shape-2 {
            right: 5%;
            top: 50%;
        }

        .blurred-shape-3 {
            left: 10%;
            bottom: 15%;
        }

        .footer-illustration {
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
        }

        .footer-illustration img {
            width: 1600px;
            max-width: none;
        }

        /* =========================
           DASHBOARD LAYOUT (Analytics Grid)
           ========================= */
        
        /* App Shell */
        .app-shell {
            display: grid;
            grid-template-columns: 260px 1fr;
            min-height: 100vh;
            position: relative;
            z-index: 10;
        }

        /* Sidebar */
        .app-sidebar {
            background: linear-gradient(to bottom, rgba(17, 24, 39, 0.95), rgba(15, 23, 42, 0.95));
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-primary);
            padding: var(--space-xl);
            display: flex;
            flex-direction: column;
            gap: var(--space-xl);
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-header {
            padding-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border-primary);
        }

        .sidebar-logo {
            font-size: var(--text-xl);
            font-weight: var(--font-bold);
            font-family: var(--font-primary);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: var(--space-xs);
        }

        .sidebar-subtitle {
            font-size: var(--text-xs);
            color: var(--text-secondary);
            font-weight: var(--font-medium);
        }

        .sidebar-back-btn {
            display: inline-flex;
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            background: var(--gradient-bg-card);
            color: var(--text-primary);
            text-decoration: none;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            border: 1px solid var(--border-primary);
            transition: all 0.2s ease;
        }

        .sidebar-back-btn:hover {
            border-color: var(--border-accent);
            transform: translateX(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .sidebar-section-label {
            font-size: var(--text-xs);
            font-weight: var(--font-semibold);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin: var(--space-lg) 0 var(--space-sm) 0;
        }

        .sidebar-link {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            background: transparent;
            color: var(--text-secondary);
            border: none;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            font-family: var(--font-body);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .sidebar-link:hover {
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-primary);
        }

        .sidebar-link.is-active {
            background: var(--gradient-button-primary);
            color: var(--color-white);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
        }

        .sidebar-icon {
            font-size: var(--text-lg);
        }

        /* Sidebar Filter Section */
        .sidebar-filter-section {
            padding: var(--space-md);
            background: rgba(15, 23, 42, 0.6);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-primary);
        }

        .sidebar-filter-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--text-xs);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }

        .sidebar-filter-value {
            font-weight: var(--font-semibold);
            color: var(--color-indigo-400);
        }

        .sidebar-slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-full);
            outline: none;
            -webkit-appearance: none;
            margin-bottom: var(--space-xs);
        }

        .sidebar-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--gradient-button-primary);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sidebar-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--gradient-button-primary);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .sidebar-filter-info {
            font-size: var(--text-xs);
            color: var(--text-tertiary);
            text-align: center;
        }

        .sidebar-clear-btn {
            background: rgba(239, 68, 68, 0.1) !important;
            color: var(--color-red-400) !important;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .sidebar-clear-btn:hover {
            background: rgba(239, 68, 68, 0.2) !important;
            color: var(--color-red-300) !important;
        }

        /* Main Content Area */
        .app-main {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Top Bar */
        .app-topbar {
            background: linear-gradient(to bottom, rgba(17, 24, 39, 0.9), rgba(15, 23, 42, 0.8));
            backdrop-filter: blur(16px);
            border-bottom: 1px solid var(--border-primary);
            padding: var(--space-lg) var(--space-2xl);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .topbar-title {
            font-size: var(--text-2xl);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .topbar-info {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin: 0;
        }

        /* Controls Toolbar */
        .controls-toolbar {
            margin: var(--space-lg) var(--space-2xl) 0;
            padding: var(--space-lg);
            display: flex;
            align-items: center;
            gap: var(--space-xl);
            flex-wrap: wrap;
        }

        .controls-left, .controls-center, .controls-right {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        .controls-left {
            flex: 1;
        }

        .toolbar-label {
            font-size: var(--text-sm);
            font-weight: var(--font-semibold);
            color: var(--text-secondary);
            margin-right: var(--space-sm);
        }

        .view-toggle-group {
            display: flex;
            gap: var(--space-xs);
            background: rgba(15, 23, 42, 0.6);
            padding: var(--space-xs);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-primary);
        }

        .view-toggle {
            padding: var(--space-sm) var(--space-lg);
            background: transparent;
            color: var(--text-secondary);
            border: none;
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            font-family: var(--font-body);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-toggle:hover {
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-primary);
        }

        .view-toggle.is-active {
            background: var(--color-indigo-600);
            color: var(--color-white);
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.4);
        }

        .clear-btn {
            padding: var(--space-sm) var(--space-lg);
            background: rgba(30, 41, 59, 0.6);
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: var(--font-medium);
            font-family: var(--font-body);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .clear-btn:hover {
            background: rgba(30, 41, 59, 0.8);
            color: var(--text-primary);
            border-color: var(--border-accent);
        }

        /* Main Content */
        .app-content {
            flex: 1;
            padding: var(--space-xl) var(--space-2xl);
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: flex;
            flex-direction: column;
            gap: var(--space-xl);
        }

        .grid-row {
            display: grid;
            gap: var(--space-xl);
        }

        .grid-row-overview {
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-template-rows: auto auto;
            gap: var(--space-xl);
            align-items: start;
        }
        
        .overview-confusion {
            grid-column: 1;
            grid-row: 1;
        }
        
        .overview-spatial {
            grid-column: 2;
            grid-row: 1;
        }
        
        .overview-metrics {
            grid-column: 1 / -1;
            grid-row: 2;
        }

        .grid-row-main {
            grid-template-columns: 1fr;
        }

        .grid-row-secondary {
            grid-template-columns: 1fr;
        }

        .grid-row-table {
            grid-template-columns: 1fr;
        }

        /* Card Styles */
        .card {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-primary);
            border-radius: var(--radius-xl);
            padding: var(--space-2xl);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--border-accent);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.6),
                        0 0 20px rgba(99, 102, 241, 0.2);
        }

        .card-hero {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8),
                        0 0 30px rgba(99, 102, 241, 0.3);
        }

        .card-title {
            font-size: var(--text-xl);
            font-weight: var(--font-semibold);
            font-family: var(--font-primary);
            background: var(--gradient-text-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 var(--space-lg) 0;
        }

        .card-visualization {
            min-height: 400px;
        }

        .card-full {
            grid-column: 1 / -1;
        }

        /* Footer */
        .app-footer-shortcuts {
            padding: 0 var(--space-2xl) var(--space-2xl);
            position: relative;
            z-index: 1;
        }

        .app-footer-shortcuts > div {
            position: relative;
            z-index: 1;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .app-shell {
                grid-template-columns: 1fr;
            }

            .app-sidebar {
                position: relative;
                height: auto;
                border-right: none;
                border-bottom: 1px solid var(--border-primary);
            }

            .grid-row-overview {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Portfolio Background Graphics (Fixed to viewport) -->
    <div class="bg-illustration hero-illustration" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/page-illustration.svg" alt="" />
    </div>
    <div class="bg-illustration secondary-illustration" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/secondary-illustration.svg" alt="" />
    </div>
    <div class="bg-illustration blurred-shape blurred-shape-1" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/blurred-shape.svg" alt="" />
    </div>
    <div class="bg-illustration blurred-shape blurred-shape-2" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/blurred-shape.svg" alt="" />
    </div>
    <div class="bg-illustration blurred-shape blurred-shape-3" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/blurred-shape.svg" alt="" />
    </div>
    <div class="bg-illustration footer-illustration" aria-hidden="true">
        <img src="../../Portfolio-Final/public/images/footer-illustration.svg" alt="" />
    </div>

    <div class="app-shell">
        <!-- Left Sidebar -->
        <aside class="app-sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo">Tile2Net Viz</div>
                <div class="sidebar-subtitle">Pedestrian Network QC</div>
            </div>

            <a href="index.html" class="sidebar-back-btn">← Back to Map</a>

            <nav class="sidebar-nav">
                <div class="sidebar-section-label">Views</div>
                <button class="sidebar-link is-active" data-nav="overview">
                    <span>Overview</span>
                </button>
                <button class="sidebar-link" data-nav="scatter">
                    <span>Scatter Plot</span>
                </button>
                <button class="sidebar-link" data-nav="parallel">
                    <span>Parallel Coords</span>
                </button>
                <button class="sidebar-link" data-nav="stats">
                    <span>Statistics</span>
                </button>
                <button class="sidebar-link" data-nav="buckets">
                    <span>Error Buckets</span>
                </button>
                <button class="sidebar-link" data-nav="table">
                    <span>Tile Table</span>
                </button>

                <div class="sidebar-section-label">Filters</div>
                <div class="sidebar-filter-section">
                    <label for="filter-threshold-sidebar" class="sidebar-filter-label">
                        <span>Minimum F1 Score (%)</span>
                        <span id="threshold-value-sidebar" class="sidebar-filter-value">0%</span>
                    </label>
                    <input type="range" id="filter-threshold-sidebar" min="0" max="100" value="0" step="1" class="sidebar-slider" />
                    <div class="sidebar-filter-info" id="threshold-info-sidebar">≥ 0% (96/96 tiles)</div>
                </div>
                
                <div class="sidebar-section-label">Actions</div>
                <button class="sidebar-link sidebar-clear-btn" onclick="clearSelection()">
                    <span>Clear Selection (<span id="selection-count-sidebar">0</span>)</span>
                </button>
            </nav>
        </aside>

        <!-- Main Content Area -->
        <div class="app-main">
            <!-- Top Bar -->
            <header class="app-topbar">
                <div class="topbar-left">
                    <h1 class="topbar-title">Tile-Level Performance Analysis</h1>
                </div>
                <div class="topbar-right">
                    <p class="topbar-info" id="header-info">Loading tile metrics...</p>
                </div>
            </header>

            <!-- Error Container -->
            <div id="error-container"></div>

            <!-- Keep real select for JS compatibility -->
            <select id="view-mode" style="display:none;">
                <option value="spatial">Spatial View</option>
                <option value="scatter">Scatter Plot</option>
                <option value="parallel">Parallel Coordinates</option>
                <option value="statistical">Statistical Analysis</option>
                <option value="erroranalysis">Error & Performance Analysis</option>
                <option value="table">Data Table</option>
            </select>

            <!-- Main Dashboard Grid -->
            <main class="app-content">
                <div class="dashboard-grid">
                    
                    <!-- Row 1: Overview - Top: Confusion Matrix + Spatial View, Bottom: Key Metrics -->
                    <section class="grid-row grid-row-overview" id="overview-row">
                        <!-- Top Left: Confusion Matrix -->
                        <div id="global-confusion-card" class="card card-hero overview-confusion">
                            <div id="global-confusion-matrix" class="global-confusion-matrix" style="display: none;">
                                <h2>Global Confusion Matrix (All Tiles)</h2>
                                <div class="cm-grid">
                                    <!-- Will be populated by renderGlobalConfusionMatrix() -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Right: Spatial View -->
                        <div class="card card-visualization overview-spatial" id="spatial-card">
                            <div id="spatial-section" style="min-height: 700px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 class="vis-title" style="margin: 0;">Spatial View: <span id="spatial-metric-label">False Positive (m)</span></h3>
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <!-- Toggle between Heatmap and Map -->
                        <div style="display: flex; background: #1e293b; border-radius: 8px; padding: 4px; border: 1px solid #334155;">
                            <button id="toggle-heatmap" style="padding: 6px 16px; background: transparent; color: #94a3b8; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">Grid</button>
                            <button id="toggle-map" style="padding: 6px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s;">Map</button>
                        </div>
                        <!-- Metric Selector -->
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="font-size: 13px; color: #94a3b8;">Metric:</label>
                            <select id="metric-select" style="padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 6px; color: #e2e8f0; font-size: 13px;">
                                <option value="f1_score" selected>F1 Score</option>
                                <option value="precision">Precision</option>
                                <option value="recall">Recall</option>
                                <option value="iou">IoU</option>
                                <option value="tp_length_m">True Positive (m)</option>
                                <option value="fp_length_m">False Positive (m)</option>
                                <option value="fn_length_m">False Negative (m)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Heatmap Grid View -->
                <div id="heatmap-view" style="display: none;">
                    <!-- Blurred Shape 1 - Behind heatmap -->
                    <div class="bg-illustration blurred-shape blurred-shape-1" aria-hidden="true" style="left: -200px; top: 100px;">
                        <img src="../../Portfolio-Final/public/images/blurred-shape.svg" alt="" />
                    </div>
                    <div class="heatmap-wrapper">
                        <div class="heatmap-main">
                            <div class="heatmap-axis-label-y">Row (North → South)</div>
                            <div class="heatmap-container">
                                <div id="heatmap-grid" class="heatmap-grid"></div>
                            </div>
                        </div>
                        <div class="heatmap-axis-label-x">Column (West → East)</div>
                    </div>
                </div>

                <!-- Interactive Map View -->
                <div id="map-view">
                    <p style="text-align: center; font-size: 13px; color: #cbd5e1; margin: 0 auto 15px; max-width: 800px; line-height: 1.6;">
                        Click tiles to see detailed metrics. Tiles colored by selected metric.
                    </p>
                    <div id="map-container" style="height: 550px; border-radius: 8px; overflow: hidden; border: 2px solid rgba(255, 255, 255, 0.1);"></div>
                </div>

                <!-- Legend (shared) -->
                <div class="legend" style="margin-top: 15px;">
                    <span>Low</span>
                    <div class="legend-bar"></div>
                    <span>High</span>
                </div>
            </div>
                        </div>
                        
                        <!-- Bottom: Key Metrics (Full Width) -->
                        <div id="metrics-summary-card" class="card card-metrics overview-metrics">
                            <h3 class="card-title">Key Metrics</h3>
                            <div id="stats-section" class="stats-grid" style="display: none;">
                                <!-- Stats will be populated here -->
                            </div>
                        </div>
                    </section>

                    <!-- Row 2: Other Visualizations (Hidden by default, shown when view changes) -->
                    <section class="grid-row grid-row-main" id="other-views-row" style="display: none;">
                        <div class="card card-visualization card-full" id="other-views-card">
                            <div id="scatter-section" style="display: none;">
                <h3 class="vis-title">Precision vs Recall Scatter Plot</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                    <!-- Left: Scatter Plot -->
                    <div>
                        <div style="height: 500px; background: rgba(15,23,42,0.3); border-radius: 6px; position: relative;" id="scatter-plot"></div>
                        <div id="scatter-legend" style="margin-top: 15px;"></div>
                    </div>
                    <!-- Right: Heatmap Grid -->
                    <div>
                        <div id="scatter-heatmap-container" style="height: 500px; overflow: auto; background: rgba(15,23,42,0.3); border-radius: 6px; padding: 15px;"></div>
                    </div>
                </div>
            </div>

                            <div id="parallel-section" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <h3 class="vis-title" style="margin: 0;">Parallel Coordinates: Multi-Metric Analysis</h3>
                        <p style="font-size: 13px; color: #cbd5e1; margin: 5px 0 0 0;">
                            Each line represents one tile across 7 metrics. Hover to highlight.
                        </p>
                    </div>
                    <div class="tile-filter-container">
                        <button class="tile-filter-dropdown-btn" onclick="toggleParallelTileDropdown()">
                            Filter Tiles: <span id="parallel-selected-count" style="color: #60a5fa; font-weight: 500;"></span>
                        </button>
                        <div id="parallel-tile-checkboxes" class="tile-checkboxes"></div>
                    </div>
                </div>

                <div id="parallel-plot" style="height: 550px; background: rgba(15,23,42,0.3); border-radius: 8px; overflow: hidden;"></div>
                <div style="display: flex; justify-content: center; gap: 30px; margin-top: 15px; padding: 12px; background: rgba(30, 41, 59, 0.5); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 30px; height: 3px; background: linear-gradient(to right, #ef4444, #f59e0b, #3b82f6, #10b981);"></div>
                        <span style="font-size: 12px; color: #e2e8f0;">Color by F1 Score (Red=Poor → Green=Excellent)</span>
                </div>
            </div>
                        </div>

                            <div id="statistical-section" style="display: none;">
                                <h3 class="vis-title">Statistical Analysis</h3>
                                
                                <!-- Distributions -->
                                <div style="margin-bottom: 40px;">
                                    <h4 style="font-size: 16px; font-weight: 600; color: #cbd5e1; margin: 20px 0 15px 20px;">Metric Distributions</h4>
                                    <div id="distributions-container" style="padding: 0 20px 20px 20px;">
                                        <!-- Will be populated by renderDistributions() -->
                                    </div>
                                </div>
                                
                                <!-- Correlation Heatmap -->
                                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 30px;">
                                    <h4 style="font-size: 16px; font-weight: 600; color: #cbd5e1; margin: 0 0 15px 0; text-align: center;">Metric Correlation Heatmap</h4>
                                    <div id="correlation-container" style="padding: 0 20px 20px 20px;">
                                        <!-- Will be populated by renderCorrelation() -->
                                    </div>
                                </div>
                            </div>

                            <div id="erroranalysis-section" style="display: none;">
                                <h3 class="vis-title">Error & Performance Analysis</h3>
                                
                                <!-- Performance Buckets -->
                                <div style="margin-bottom: 40px;">
                                    <h4 style="font-size: 16px; font-weight: 600; color: #cbd5e1; margin: 20px 0 15px 0; text-align: center;">Performance Buckets</h4>
                                    <p style="text-align: center; font-size: 13px; color: #cbd5e1; margin: 0 auto 20px; max-width: 800px; line-height: 1.6;">
                                        Each mini-grid shows the <strong>spatial location</strong> of tiles in that F1 range. 
                                        Brighter tiles = higher F1 within the bucket. Helps identify if poor performance is clustered in specific areas.
                                    </p>
                                    <div id="buckets-container" style="padding: 20px;">
                                        <!-- Will be populated by renderBuckets() -->
                                    </div>
                                    <p style="text-align: center; font-size: 12px; color: #94a3b8; margin-top: 12px;">Tiles grouped by F1 Score: Excellent (≥90%), Good (70-90%), Fair (50-70%), Poor (<50%)</p>
                                </div>
                                
                                <!-- Error Composition -->
                                <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 30px;">
                                    <h4 style="font-size: 16px; font-weight: 600; color: #cbd5e1; margin: 0 0 15px 20px;">Error Composition (Top 50 Tiles)</h4>
                                    <div id="composition-container" style="padding: 0 20px 20px 20px;">
                                        <!-- Will be populated by renderComposition() -->
                                    </div>
                                </div>
                            </div>

                            <div id="table-section" style="display: none;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                    <h3 class="vis-title" style="margin: 0;">Data Table</h3>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <label style="font-size: 13px; color: #94a3b8;">Sort By:</label>
                                        <select id="sort-select" style="padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 6px; color: #e2e8f0; font-size: 13px;">
                                            <option value="f1_score">F1 Score</option>
                                            <option value="precision">Precision</option>
                                            <option value="recall">Recall</option>
                                            <option value="iou">IoU</option>
                                            <option value="tp_length_m">True Positive (m)</option>
                                            <option value="fp_length_m">False Positive (m)</option>
                                            <option value="fn_length_m">False Negative (m)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="table-container">
                                    <table id="data-table">
                                        <thead>
                                            <tr>
                                                <th>Tile</th>
                                                <th>Coordinates</th>
                                                <th>F1 Score</th>
                                                <th>Precision</th>
                                                <th>Recall</th>
                                                <th>IoU</th>
                                                <th>TP (m)</th>
                                                <th>FP (m)</th>
                                                <th>FN (m)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="table-body">
                                            <!-- Will be populated -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </section>

                </div>
            </main>

            <!-- Footer with Shortcuts -->
            <footer class="app-footer-shortcuts">
                <!-- Feature Hint Banner (Portfolio CTA Style) -->
                <div style="
            background: var(--gradient-bg-card);
            backdrop-filter: blur(16px);
            padding: var(--space-xl) var(--space-2xl);
            border-radius: var(--radius-xl);
            margin-top: var(--space-2xl);
            border: 1px solid var(--border-accent);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.6), 0 0 20px rgba(99, 102, 241, 0.3);
        ">
            <div style="display: flex; align-items: center; gap: var(--space-md); margin-bottom: var(--space-lg);">
                <strong style="
                    color: var(--text-primary);
                    font-size: var(--text-xl);
                    font-family: var(--font-primary);
                    font-weight: var(--font-semibold);
                    background: var(--gradient-text-primary);
                    background-clip: text;
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                ">Keyboard Shortcuts</strong>
            </div>
            <div style="
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: var(--space-lg);
                color: var(--text-secondary);
                font-size: var(--text-sm);
            ">
                <div>
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Ctrl</kbd> + 
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Click</kbd>
                    <span style="margin-left: var(--space-sm);">Open tile detail modal</span>
                </div>
                <div>
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Arrow Keys</kbd>
                    <span style="margin-left: var(--space-sm);">Navigate between tiles</span>
                </div>
                <div>
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Enter</kbd> / 
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Space</kbd>
                    <span style="margin-left: var(--space-sm);">Open modal for selected tile</span>
                </div>
                <div>
                    <kbd style="
                        background: rgba(99, 102, 241, 0.2);
                        padding: var(--space-xs) var(--space-sm);
                        border-radius: var(--radius-md);
                        font-size: var(--text-xs);
                        font-weight: var(--font-semibold);
                        border: 1px solid var(--border-accent);
                        font-family: var(--font-body);
                    ">Esc</kbd>
                    <span style="margin-left: var(--space-sm);">Close modal</span>
                </div>
            </div>
                </div>
            </footer>
        </div>
    </div>

    <!-- Tile Detail Modal (Feature #8) -->
    <div id="tile-detail-backdrop" class="modal-backdrop"></div>
    <div id="tile-detail-modal" class="tile-modal">
        <div class="modal-header">
            <h2 id="modal-title">Tile Details</h2>
            <button id="modal-close-btn" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
            <!-- Section 1: Metric Cards -->
            <div id="modal-metrics" class="modal-section"></div>
            
            <!-- Section 2: Confusion Matrix Details -->
            <div id="modal-confusion" class="modal-section"></div>
            
            <!-- Section 3: Raw Data Table -->
            <div id="modal-raw-data" class="modal-section"></div>
            
            <!-- Section 4: Mini Leaflet Map (Feature #10) -->
            <div class="modal-section">
                <h3>Geographic Location</h3>
                <div id="tile-mini-map" style="height: 300px; border-radius: 8px;"></div>
            </div>
        </div>
    </div>

    <script>
        // =========================
        // DASHBOARD LAYOUT CONTROLS
        // =========================
        
        // Wire sidebar navigation to control views
        document.addEventListener('DOMContentLoaded', () => {
            const viewModeSelect = document.getElementById('view-mode');
            const otherViewsRow = document.getElementById('other-views-row');
            const overviewRow = document.getElementById('overview-row');
            
            // Function to toggle between overview and other views
            function updateViewLayout(view) {
                if (view === 'overview' || view === 'spatial') {
                    overviewRow.style.display = '';
                    otherViewsRow.style.display = 'none';
                } else {
                    overviewRow.style.display = 'none';
                    otherViewsRow.style.display = '';
                }
            }
            
            // Listen to view-mode select changes to keep layout in sync
            viewModeSelect.addEventListener('change', () => {
                updateViewLayout(viewModeSelect.value);
                render(); // Re-render to show the selected view content
            });

            // Sidebar navigation
            const sidebarLinks = document.querySelectorAll('.sidebar-link');
            sidebarLinks.forEach(link => {
                link.addEventListener('click', () => {
                    const nav = link.dataset.nav;
                    
                    // Update active states
                    sidebarLinks.forEach(l => l.classList.remove('is-active'));
                    link.classList.add('is-active');
                    
                    // Handle navigation
                    if (nav === 'overview') {
                        // Show overview and scroll to top
                        viewModeSelect.value = 'spatial';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('overview');
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    } else if (nav === 'scatter') {
                        viewModeSelect.value = 'scatter';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('scatter');
                        document.getElementById('other-views-row')?.scrollIntoView({ behavior: 'smooth' });
                    } else if (nav === 'parallel') {
                        viewModeSelect.value = 'parallel';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('parallel');
                        document.getElementById('other-views-row')?.scrollIntoView({ behavior: 'smooth' });
                    } else if (nav === 'stats') {
                        viewModeSelect.value = 'statistical';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('statistical');
                        document.getElementById('other-views-row')?.scrollIntoView({ behavior: 'smooth' });
                    } else if (nav === 'buckets') {
                        viewModeSelect.value = 'erroranalysis';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('erroranalysis');
                        document.getElementById('other-views-row')?.scrollIntoView({ behavior: 'smooth' });
                    } else if (nav === 'table') {
                        viewModeSelect.value = 'table';
                        viewModeSelect.dispatchEvent(new Event('change'));
                        updateViewLayout('table');
                        document.getElementById('other-views-row')?.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });
        });

        // Metrics config
        const metricsConfig = {
            f1_score: { label: 'F1 Score', isPercentage: true },
            precision: { label: 'Precision', isPercentage: true },
            recall: { label: 'Recall', isPercentage: true },
            iou: { label: 'IoU', isPercentage: true },
            tp_length_m: { label: 'True Positive (m)', isPercentage: false },
            fp_length_m: { label: 'False Positive (m)', isPercentage: false },
            fn_length_m: { label: 'False Negative (m)', isPercentage: false }
        };

        let data = null;
        let stats = null;
        let gridLayout = null;
        let filterThreshold = 0; // F1 score threshold (0-100)
        let parallelSelectedTiles = new Set(); // Track selected tiles for parallel coordinates

        // Get filtered data based on threshold
        function getFilteredData() {
            if (!data) return [];
            const threshold = filterThreshold / 100; // Convert percentage to decimal
            return data.filter(d => (d.f1_score || 0) >= threshold);
        }

        // Load data
        async function loadData() {
            try {
                const response = await fetch('confusion_matrix_per_tile.json');
                if (!response.ok) throw new Error(`Failed to load: ${response.status}`);
                data = await response.json();
                processData();
                
                // Initialize sidebar filter display
                const thresholdInfoSidebar = document.getElementById('threshold-info-sidebar');
                if (data && thresholdInfoSidebar) {
                    thresholdInfoSidebar.textContent = `≥ 0% (${data.length}/${data.length} tiles)`;
                }
                
                render();
            } catch (error) {
                showError(`Error loading tile metrics: ${error.message}`);
                console.error(error);
            }
        }

        function processData() {
            // Calculate grid layout
            const minX = Math.min(...data.map(d => d.xtile));
            const maxX = Math.max(...data.map(d => d.xtile));
            const minY = Math.min(...data.map(d => d.ytile));
            const maxY = Math.max(...data.map(d => d.ytile));

            gridLayout = {
                cols: maxX - minX + 1,
                rows: maxY - minY + 1,
                minX, minY, maxX, maxY
            };

            // Calculate stats
            stats = {
                total_tiles: data.length
            };

            Object.keys(metricsConfig).forEach(key => {
                const values = data.map(d => d[key] || 0);
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                const sorted = [...values].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const min = Math.min(...values);
                const max = Math.max(...values);

                stats[key] = { avg, median, min, max };
            });

            document.getElementById('header-info').textContent = 
                `Analyzing ${data.length} tiles • Grid: ${gridLayout.cols}×${gridLayout.rows}`;
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">${message}</div>`;
        }

        function formatValue(value, isPercentage) {
            return isPercentage ? (value * 100).toFixed(1) + '%' : value.toFixed(1);
        }

        function getColorIntensity(value, metricKey) {
            const isLength = metricKey.includes('length');
            if (isLength) {
                const max = Math.max(...data.map(d => d[metricKey] || 0));
                return value / (max || 1);
            }
            return value;
        }

        function getHeatmapColor(value, metricKey) {
            const intensity = getColorIntensity(value, metricKey);

            if (metricKey === 'fp_length_m' || metricKey === 'fn_length_m') {
                // Muted red gradient for errors
                const r = 80 + Math.floor(60 * intensity);
                const g = Math.floor(20 * (1 - intensity));
                const b = Math.floor(20 * (1 - intensity));
                return `rgb(${r}, ${g}, ${b})`;
            } else if (metricKey === 'tp_length_m') {
                // Muted green gradient for true positives
                const r = Math.floor(20 * (1 - intensity));
                const g = 60 + Math.floor(80 * intensity);
                const b = Math.floor(30 * (1 - intensity));
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Subtle Red-Yellow-Green gradient for performance metrics
                if (intensity < 0.5) {
                    // Dark red to yellow-orange (0 to 0.5)
                    const t = intensity * 2;
                    const r = Math.floor(120 + 40 * t);
                    const g = Math.floor(40 + 80 * t);
                    const b = 35;
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    // Yellow-orange to green (0.5 to 1.0)
                    const t = (intensity - 0.5) * 2;
                    const r = Math.floor(160 - 90 * t);
                    const g = Math.floor(120 + 40 * t);
                    const b = Math.floor(35 + 15 * t);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
        }

        function renderGlobalConfusionMatrix(data) {
            const container = document.querySelector('.cm-grid');
            const section = document.getElementById('global-confusion-matrix');
            if (!container || !section) return;

            // Sum TP/FP/FN across all tiles
            let totalTP = 0;
            let totalFP = 0;
            let totalFN = 0;

            data.forEach(tile => {
                totalTP += tile.tp_length_m || 0;
                totalFP += tile.fp_length_m || 0;
                totalFN += tile.fn_length_m || 0;
            });

            const total = totalTP + totalFP + totalFN;

            // Calculate percentages
            const tpPct = total > 0 ? ((totalTP / total) * 100).toFixed(1) : '0.0';
            const fpPct = total > 0 ? ((totalFP / total) * 100).toFixed(1) : '0.0';
            const fnPct = total > 0 ? ((totalFN / total) * 100).toFixed(1) : '0.0';

            // Format lengths (convert to km if > 1000m)
            const formatLength = (m) => {
                return m >= 1000 ? `${(m / 1000).toFixed(2)} km` : `${m.toFixed(0)} m`;
            };

            // Generate HTML
            container.innerHTML = `
                <div class="cm-cell tp">
                    <h3>True Positive (TP)</h3>
                    <div class="value">${formatLength(totalTP)}</div>
                    <div class="percentage">${tpPct}%</div>
                </div>
                <div class="cm-cell fp">
                    <h3>False Positive (FP)</h3>
                    <div class="value">${formatLength(totalFP)}</div>
                    <div class="percentage">${fpPct}%</div>
                </div>
                <div class="cm-cell fn">
                    <h3>False Negative (FN)</h3>
                    <div class="value">${formatLength(totalFN)}</div>
                    <div class="percentage">${fnPct}%</div>
                </div>
                <div class="cm-cell total">
                    <h3>Total Evaluated</h3>
                    <div class="value">${formatLength(total)}</div>
                    <div class="percentage">100%</div>
                </div>
            `;

            // Show the section
            section.style.display = 'block';
        }

        function renderGlobalConfusionMatrix(data) {
            const container = document.querySelector('.cm-grid');
            const section = document.getElementById('global-confusion-matrix');
            if (!container || !section) return;

            // Sum TP/FP/FN across all tiles
            let totalTP = 0;
            let totalFP = 0;
            let totalFN = 0;

            data.forEach(tile => {
                totalTP += tile.tp_length_m || 0;
                totalFP += tile.fp_length_m || 0;
                totalFN += tile.fn_length_m || 0;
            });

            const total = totalTP + totalFP + totalFN;

            // Calculate percentages
            const tpPct = total > 0 ? ((totalTP / total) * 100).toFixed(1) : '0.0';
            const fpPct = total > 0 ? ((totalFP / total) * 100).toFixed(1) : '0.0';
            const fnPct = total > 0 ? ((totalFN / total) * 100).toFixed(1) : '0.0';

            // Format lengths (convert to km if > 1000m)
            const formatLength = (m) => {
                return m >= 1000 ? `${(m / 1000).toFixed(2)} km` : `${m.toFixed(0)} m`;
            };

            // Generate HTML
            container.innerHTML = `
                <div class="cm-cell tp">
                    <h3>True Positive (TP)</h3>
                    <div class="value">${formatLength(totalTP)}</div>
                    <div class="percentage">${tpPct}%</div>
                </div>
                <div class="cm-cell fp">
                    <h3>False Positive (FP)</h3>
                    <div class="value">${formatLength(totalFP)}</div>
                    <div class="percentage">${fpPct}%</div>
                </div>
                <div class="cm-cell fn">
                    <h3>False Negative (FN)</h3>
                    <div class="value">${formatLength(totalFN)}</div>
                    <div class="percentage">${fnPct}%</div>
                </div>
                <div class="cm-cell total">
                    <h3>Total Evaluated</h3>
                    <div class="value">${formatLength(total)}</div>
                    <div class="percentage">100%</div>
                </div>
            `;

            // Show the section
            section.style.display = 'block';
        }

        function renderGlobalConfusionMatrix(data) {
            const container = document.querySelector('.cm-grid');
            const section = document.getElementById('global-confusion-matrix');
            if (!container || !section) return;

            // Sum TP/FP/FN across all tiles
            let totalTP = 0;
            let totalFP = 0;
            let totalFN = 0;

            data.forEach(tile => {
                totalTP += tile.tp_length_m || 0;
                totalFP += tile.fp_length_m || 0;
                totalFN += tile.fn_length_m || 0;
            });

            const total = totalTP + totalFP + totalFN;

            // Calculate percentages
            const tpPct = total > 0 ? ((totalTP / total) * 100).toFixed(1) : '0.0';
            const fpPct = total > 0 ? ((totalFP / total) * 100).toFixed(1) : '0.0';
            const fnPct = total > 0 ? ((totalFN / total) * 100).toFixed(1) : '0.0';

            // Format lengths (convert to km if > 1000m)
            const formatLength = (m) => {
                return m >= 1000 ? `${(m / 1000).toFixed(2)} km` : `${m.toFixed(0)} m`;
            };

            // Generate HTML
            container.innerHTML = `
                <div class="cm-cell tp">
                    <h3>True Positive (TP)</h3>
                    <div class="value">${formatLength(totalTP)}</div>
                    <div class="percentage">${tpPct}%</div>
                </div>
                <div class="cm-cell fp">
                    <h3>False Positive (FP)</h3>
                    <div class="value">${formatLength(totalFP)}</div>
                    <div class="percentage">${fpPct}%</div>
                </div>
                <div class="cm-cell fn">
                    <h3>False Negative (FN)</h3>
                    <div class="value">${formatLength(totalFN)}</div>
                    <div class="percentage">${fnPct}%</div>
                </div>
                <div class="cm-cell total">
                    <h3>Total Evaluated</h3>
                    <div class="value">${formatLength(total)}</div>
                    <div class="percentage">100%</div>
                </div>
            `;

            // Show the section
            section.style.display = 'block';
        }

        function createSparkline(values, width, height, color) {
            if (values.length === 0) return '';
            
            // Use 0-1 range for percentage metrics to show absolute scale differences
            const min = 0;
            const max = 1;
            const range = max - min;
            
            // Create points for the line
            const points = values.map((val, idx) => {
                const x = (idx / (values.length - 1)) * width;
                const y = height - ((val - min) / range) * height;
                return `${x},${y}`;
            }).join(' ');
            
            // Create area fill points (close the path at bottom)
            const areaPoints = points + ` ${width},${height} 0,${height}`;
            
            // Add median line for reference
            const sortedVals = [...values].sort((a, b) => a - b);
            const median = sortedVals[Math.floor(sortedVals.length / 2)];
            const medianY = height - ((median - min) / range) * height;
            
            return `
                <svg width="${width}" height="${height}" style="display: block;">
                    <defs>
                        <linearGradient id="sparkGradient-${color.replace('#', '')}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:0.4" />
                            <stop offset="100%" style="stop-color:${color};stop-opacity:0.05" />
                        </linearGradient>
                    </defs>
                    <line x1="0" y1="${medianY}" x2="${width}" y2="${medianY}" stroke="rgba(255,255,255,0.15)" stroke-width="1" stroke-dasharray="2,2" />
                    <polygon points="${areaPoints}" fill="url(#sparkGradient-${color.replace('#', '')})" />
                    <polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" />
                </svg>
            `;
        }

        function renderStats() {
            const statsSection = document.getElementById('stats-section');
            statsSection.innerHTML = '';

            const metricKeys = ['f1_score', 'precision', 'recall', 'iou'];
            const colors = ['#3b82f6', '#10b981', '#a855f7', '#f97316'];

            metricKeys.forEach((key, idx) => {
                const s = stats[key];
                const cfg = metricsConfig[key];
                
                // Get all values for sparkline and SORT them to show distribution
                const values = data.map(d => d[key] || 0).sort((a, b) => a - b);
                
                const card = document.createElement('div');
                card.className = 'stat-card';
                
                // Create sparkline SVG
                const sparklineWidth = 80;
                const sparklineHeight = 30;
                const sparklineSVG = createSparkline(values, sparklineWidth, sparklineHeight, colors[idx]);
                
                card.innerHTML = `
                    <div class="stat-label">
                        <span class="stat-dot" style="background: ${colors[idx]}"></span>
                        ${cfg.label}
                    </div>
                    <div class="stat-value">${formatValue(s.avg, cfg.isPercentage)}</div>
                    <div class="stat-sparkline">${sparklineSVG}</div>
                    <div class="stat-range">
                        Range: ${formatValue(s.min, cfg.isPercentage)} - ${formatValue(s.max, cfg.isPercentage)}
                    </div>
                `;
                statsSection.appendChild(card);
            });

            statsSection.style.display = 'grid';
        }

        let map = null;
        let tileLayer = null;
        let rectangles = [];

        function renderMap(filteredData = data) {
            const metricKey = document.getElementById('metric-select').value;
            const container = document.getElementById('map-container');
            
            // Update metric label
            document.getElementById('spatial-metric-label').textContent = metricsConfig[metricKey].label;

            // Initialize map if not already done
            if (!map) {
                // Calculate center from data
                const lats = data.map(t => t.lat);
                const lons = data.map(t => t.lon);
                const centerLat = (Math.max(...lats) + Math.min(...lats)) / 2;
                const centerLon = (Math.max(...lons) + Math.min(...lons)) / 2;

                map = L.map('map-container').setView([centerLat, centerLon], 15);
                
                // Add tile layer
                tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(map);
            }

            // Clear existing rectangles
            rectangles.forEach(rect => rect.remove());
            rectangles = [];

            // Calculate tile size (approximate, assuming consistent grid)
            const sortedByX = [...data].sort((a, b) => a.xtile - b.xtile);
            const sortedByY = [...data].sort((a, b) => a.ytile - b.ytile);
            
            // Estimate tile size from data spread
            const lonSpan = Math.abs(sortedByX[sortedByX.length - 1].lon - sortedByX[0].lon) / gridLayout.cols;
            const latSpan = Math.abs(sortedByY[sortedByY.length - 1].lat - sortedByY[0].lat) / gridLayout.rows;

            // Draw rectangles for each tile
            data.forEach(tile => {
                const value = tile[metricKey] || 0;
                const color = getHeatmapColor(value, metricKey);
                
                // Create bounds (tile corners)
                const bounds = [
                    [tile.lat - latSpan / 2, tile.lon - lonSpan / 2],
                    [tile.lat + latSpan / 2, tile.lon + lonSpan / 2]
                ];

                // Highlight if selected
                const isSelected = selectedTiles.has(tile.tile_id);
                
                const rectangle = L.rectangle(bounds, {
                    color: isSelected ? '#facc15' : color,
                    fillColor: color,
                    fillOpacity: 0.6,
                    weight: isSelected ? 4 : 1,
                    opacity: isSelected ? 1 : 0.8
                }).addTo(map);
                
                // Click to select
                rectangle.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleTileSelection(tile.tile_id, e.originalEvent);
                });

                // Popup content
                const popupContent = `
                    <div style="font-family: sans-serif; min-width: 180px;">
                        <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #10b981;">
                            Tile ${tile.tile_id}
                        </div>
                        <div style="margin-bottom: 6px;">
                            <strong>${metricsConfig[metricKey].label}:</strong> 
                            ${formatValue(value, metricsConfig[metricKey].isPercentage)}
                        </div>
                        <div style="font-size: 12px; padding-top: 6px; border-top: 1px solid #ddd;">
                            <div style="margin-bottom: 3px;"><strong>F1:</strong> ${formatValue(tile.f1_score, true)}</div>
                            <div style="margin-bottom: 3px;"><strong>Precision:</strong> ${formatValue(tile.precision, true)}</div>
                            <div style="margin-bottom: 3px;"><strong>Recall:</strong> ${formatValue(tile.recall, true)}</div>
                            <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #ddd; color: #666; font-size: 11px;">
                                Position: (${tile.xtile}, ${tile.ytile})<br>
                                Coords: ${tile.lat.toFixed(6)}°, ${tile.lon.toFixed(6)}°
                            </div>
                        </div>
                    </div>
                `;

                rectangle.bindPopup(popupContent);
                
                // Hover effect
                rectangle.on('mouseover', function() {
                    this.setStyle({ weight: 3, fillOpacity: 0.8 });
                });
                
                rectangle.on('mouseout', function() {
                    this.setStyle({ weight: 1, fillOpacity: 0.6 });
                });

                rectangles.push(rectangle);
            });

            // Fit bounds to show all tiles
            if (rectangles.length > 0) {
                const group = L.featureGroup(rectangles);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        function renderHeatmap(filteredData = data) {
            const metricKey = document.getElementById('metric-select').value;
            const filteredIds = new Set(filteredData.map(t => t.tile_id));

            const grid = document.getElementById('heatmap-grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${gridLayout.cols}, 48px)`;

            for (let row = 0; row < gridLayout.rows; row++) {
                for (let col = 0; col < gridLayout.cols; col++) {
                    const tile = data.find(
                        t => t.xtile === gridLayout.minX + col && t.ytile === gridLayout.minY + row
                    );

                    const cell = document.createElement('div');
                    cell.className = 'heatmap-cell';

                    if (!tile) {
                        cell.classList.add('empty');
                    } else if (!filteredIds.has(tile.tile_id)) {
                        // Tile filtered out - show as grayed out
                        cell.style.backgroundColor = 'rgba(100, 100, 100, 0.15)';
                        cell.style.opacity = '0.4';
                        cell.textContent = String(tile.tile_id).substring(0, 3);
                    } else {
                        const value = tile[metricKey] || 0;

                        const bgColor = getHeatmapColor(value, metricKey);
                        cell.style.backgroundColor = bgColor;
                        cell.textContent = String(tile.tile_id).substring(0, 3);
                        cell.style.cursor = 'pointer';
                        
                        // Highlight if selected
                        if (selectedTiles.has(tile.tile_id)) {
                            cell.style.border = '3px solid #facc15';
                            cell.style.boxShadow = '0 0 10px rgba(250, 204, 21, 0.6)';
                        }

                        // Click to select
                        cell.addEventListener('click', (e) => {
                            toggleTileSelection(tile.tile_id, e);
                        });

                        let tooltip = null;
                        cell.addEventListener('mouseenter', (e) => {
                            tooltip = document.createElement('div');
                            tooltip.style.position = 'fixed';
                            tooltip.style.left = `${e.clientX + 12}px`;
                            tooltip.style.top = `${e.clientY - 12}px`;
                            tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                            tooltip.style.color = '#fff';
                            tooltip.style.padding = '10px 14px';
                            tooltip.style.borderRadius = '6px';
                            tooltip.style.fontSize = '12px';
                            tooltip.style.zIndex = '10000';
                            tooltip.style.pointerEvents = 'none';
                            tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                            tooltip.style.minWidth = '150px';
                            tooltip.innerHTML = `
                                <div style="font-weight: bold; margin-bottom: 6px; color: #10b981;">Tile ${tile.tile_id}</div>
                                <div style="margin-bottom: 4px;"><strong>${metricsConfig[metricKey].label}:</strong> ${formatValue(value, metricsConfig[metricKey].isPercentage)}</div>
                                <div style="font-size: 10px; color: #94a3b8; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">Position: Col ${col}, Row ${row}</div>
                                <div style="font-size: 10px; color: #94a3b8;">Coords: (${tile.xtile}, ${tile.ytile})</div>
                            `;
                            document.body.appendChild(tooltip);
                        });

                        cell.addEventListener('mousemove', (e) => {
                            if (tooltip) {
                                tooltip.style.left = `${e.clientX + 12}px`;
                                tooltip.style.top = `${e.clientY - 12}px`;
                            }
                        });

                        cell.addEventListener('mouseleave', () => {
                            if (tooltip) {
                                document.body.removeChild(tooltip);
                                tooltip = null;
                            }
                        });
                    }

                    grid.appendChild(cell);
                }
            }

            document.getElementById('spatial-metric-label').textContent = metricsConfig[metricKey].label;
        }

        function renderScatter(filteredData = data) {
            // Remove all existing tooltips (including scatter-specific ones)
            document.querySelectorAll('[id$="-tooltip"]').forEach(t => t.remove());
            document.querySelectorAll('[id^="scatter-tooltip-"]').forEach(t => t.remove());
            
            const plot = document.getElementById('scatter-plot');
            plot.innerHTML = '';

            // SVG dimensions (compact for side-by-side layout)
            const width = 550;
            const height = 500;
            const margin = { top: 20, right: 20, bottom: 60, left: 70 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            plot.appendChild(svg);

            // Create group for plot area
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Scales (0-100% for both axes)
            const xScale = (val) => (val / 100) * plotWidth;
            const yScale = (val) => plotHeight - (val / 100) * plotHeight;

            // Draw axes background
            const axisRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            axisRect.setAttribute('x', 0);
            axisRect.setAttribute('y', 0);
            axisRect.setAttribute('width', plotWidth);
            axisRect.setAttribute('height', plotHeight);
            axisRect.setAttribute('fill', 'rgba(15, 23, 42, 0.3)');
            axisRect.setAttribute('stroke', '#334155');
            axisRect.setAttribute('stroke-width', 1);
            g.appendChild(axisRect);

            // Draw grid lines
            for (let i = 0; i <= 100; i += 10) {
                // Vertical grid lines
                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', xScale(i));
                vLine.setAttribute('y1', 0);
                vLine.setAttribute('x2', xScale(i));
                vLine.setAttribute('y2', plotHeight);
                vLine.setAttribute('stroke', i % 20 === 0 ? '#334155' : '#1e293b');
                vLine.setAttribute('stroke-width', 1);
                vLine.setAttribute('opacity', 0.5);
                g.appendChild(vLine);

                // Horizontal grid lines
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', 0);
                hLine.setAttribute('y1', yScale(i));
                hLine.setAttribute('x2', plotWidth);
                hLine.setAttribute('y2', yScale(i));
                hLine.setAttribute('stroke', i % 20 === 0 ? '#334155' : '#1e293b');
                hLine.setAttribute('stroke-width', 1);
                hLine.setAttribute('opacity', 0.5);
                g.appendChild(hLine);
            }

            // Draw diagonal reference line (Precision = Recall)
            const diagonal = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            diagonal.setAttribute('x1', xScale(0));
            diagonal.setAttribute('y1', yScale(0));
            diagonal.setAttribute('x2', xScale(100));
            diagonal.setAttribute('y2', yScale(100));
            diagonal.setAttribute('stroke', '#10b981');
            diagonal.setAttribute('stroke-width', 2);
            diagonal.setAttribute('stroke-dasharray', '6,4');
            diagonal.setAttribute('opacity', 0.4);
            g.appendChild(diagonal);

            // Draw axes borders (make them more prominent)
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0);
            xAxis.setAttribute('y1', plotHeight);
            xAxis.setAttribute('x2', plotWidth);
            xAxis.setAttribute('y2', plotHeight);
            xAxis.setAttribute('stroke', '#64748b');
            xAxis.setAttribute('stroke-width', 2);
            g.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', 0);
            yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', 0);
            yAxis.setAttribute('y2', plotHeight);
            yAxis.setAttribute('stroke', '#64748b');
            yAxis.setAttribute('stroke-width', 2);
            g.appendChild(yAxis);

            // Add axis labels and ticks
            for (let i = 0; i <= 100; i += 20) {
                // X-axis ticks and labels
                const xTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                xTick.setAttribute('x1', xScale(i));
                xTick.setAttribute('y1', plotHeight);
                xTick.setAttribute('x2', xScale(i));
                xTick.setAttribute('y2', plotHeight + 6);
                xTick.setAttribute('stroke', '#94a3b8');
                xTick.setAttribute('stroke-width', 2);
                g.appendChild(xTick);

                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xScale(i));
                xLabel.setAttribute('y', plotHeight + 24);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('fill', '#cbd5e1');
                xLabel.setAttribute('font-size', '13px');
                xLabel.setAttribute('font-weight', '500');
                xLabel.textContent = `${i}%`;
                g.appendChild(xLabel);

                // Y-axis ticks and labels
                const yTick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                yTick.setAttribute('x1', -6);
                yTick.setAttribute('y1', yScale(i));
                yTick.setAttribute('x2', 0);
                yTick.setAttribute('y2', yScale(i));
                yTick.setAttribute('stroke', '#94a3b8');
                yTick.setAttribute('stroke-width', 2);
                g.appendChild(yTick);

                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -12);
                yLabel.setAttribute('y', yScale(i));
                yLabel.setAttribute('text-anchor', 'end');
                yLabel.setAttribute('dominant-baseline', 'middle');
                yLabel.setAttribute('fill', '#cbd5e1');
                yLabel.setAttribute('font-size', '13px');
                yLabel.setAttribute('font-weight', '500');
                yLabel.textContent = `${i}%`;
                g.appendChild(yLabel);
            }

            // Axis titles
            const xTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xTitle.setAttribute('x', plotWidth / 2);
            xTitle.setAttribute('y', plotHeight + 50);
            xTitle.setAttribute('text-anchor', 'middle');
            xTitle.setAttribute('fill', '#f1f5f9');
            xTitle.setAttribute('font-size', '15px');
            xTitle.setAttribute('font-weight', 'bold');
            xTitle.textContent = 'Precision (%)';
            g.appendChild(xTitle);

            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('x', -plotHeight / 2);
            yTitle.setAttribute('y', -50);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('fill', '#f1f5f9');
            yTitle.setAttribute('font-size', '15px');
            yTitle.setAttribute('font-weight', 'bold');
            yTitle.setAttribute('transform', 'rotate(-90)');
            yTitle.textContent = 'Recall (%)';
            g.appendChild(yTitle);

            // Helper function to get color based on F1 score
            const getF1Color = (f1) => {
                if (f1 >= 0.9) return '#10b981'; // Green - Excellent
                if (f1 >= 0.7) return '#3b82f6'; // Blue - Good
                if (f1 >= 0.5) return '#f59e0b'; // Orange - Fair
                return '#ef4444'; // Red - Poor
            };

            // Plot points for each filtered tile
            filteredData.forEach(tile => {
                const precision = (tile.precision * 100) || 0;
                const recall = (tile.recall * 100) || 0;
                const f1 = tile.f1_score || 0;
                const iou = tile.iou || 0;

                const cx = xScale(precision);
                const cy = yScale(recall);

                // Get color based on F1 score
                const color = getF1Color(f1);
                const isSelected = selectedTiles.has(tile.tile_id);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', isSelected ? 9 : 6);
                circle.setAttribute('fill', color);
                circle.setAttribute('stroke', isSelected ? '#facc15' : '#fff');
                circle.setAttribute('stroke-width', isSelected ? 3 : 1.5);
                circle.setAttribute('opacity', isSelected ? 1 : 0.8);
                circle.style.cursor = 'pointer';
                circle.style.transition = 'all 0.2s';
                
                // Add tooltip hint
                const titleElem = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                titleElem.textContent = `Tile ${tile.tile_id}: Click to select, Ctrl+Click for details`;
                circle.appendChild(titleElem);
                
                // Click to select, Ctrl+Click to open modal
                circle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (e.ctrlKey || e.metaKey) {
                        openTileDetailModal(tile);
                    } else {
                        toggleTileSelection(tile.tile_id, e);
                    }
                });

                // Tooltip on hover
                const tooltipId = `scatter-tooltip-${tile.tile_id}`;
                circle.addEventListener('mouseenter', (e) => {
                    // Remove any existing tooltips first
                    document.querySelectorAll('[id^="scatter-tooltip-"]').forEach(t => t.remove());
                    
                    circle.setAttribute('r', 9);
                    circle.setAttribute('stroke-width', 2.5);
                    circle.setAttribute('opacity', 1);

                    // Create tooltip
                    const tooltip = document.createElement('div');
                    tooltip.id = tooltipId;
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = `${e.clientX + 12}px`;
                    tooltip.style.top = `${e.clientY - 12}px`;
                    tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                    tooltip.style.color = '#fff';
                    tooltip.style.padding = '12px 16px';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.fontSize = '13px';
                    tooltip.style.zIndex = '10000';
                    tooltip.style.pointerEvents = 'none';
                    tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                    tooltip.style.border = `2px solid ${color}`;
                    tooltip.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 6px; color: ${color};">${tile.tile_id}</div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Precision:</span> <strong>${precision.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Recall:</span> <strong>${recall.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">F1 Score:</span> <strong>${(f1 * 100).toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">IoU:</span> <strong>${(iou * 100).toFixed(1)}%</strong></div>
                    `;
                    document.body.appendChild(tooltip);
                });

                circle.addEventListener('mousemove', (e) => {
                    const tooltip = document.getElementById(tooltipId);
                    if (tooltip) {
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                    }
                });

                circle.addEventListener('mouseleave', () => {
                    circle.setAttribute('r', 6);
                    circle.setAttribute('stroke-width', 1.5);
                    circle.setAttribute('opacity', 0.8);

                    const tooltip = document.getElementById(tooltipId);
                    if (tooltip) {
                        tooltip.remove();
                    }
                });

                g.appendChild(circle);
            });

            // Create legend in separate container below scatter plot
            const legendContainer = document.getElementById('scatter-legend');
            legendContainer.innerHTML = '';
            legendContainer.style.cssText = 'display: flex; justify-content: center; gap: 20px; padding: 10px; background: rgba(30, 41, 59, 0.5); border-radius: 8px;';
            
            const legendData = [
                { label: 'Excellent (≥90%)', color: '#10b981' },
                { label: 'Good (70-90%)', color: '#3b82f6' },
                { label: 'Fair (50-70%)', color: '#f59e0b' },
                { label: 'Poor (<50%)', color: '#ef4444' }
            ];

            legendData.forEach(item => {
                const legendItem = document.createElement('div');
                legendItem.style.cssText = 'display: flex; align-items: center; gap: 6px;';
                legendItem.innerHTML = `
                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${item.color}; border: 2px solid white;"></div>
                    <span style="font-size: 12px; color: #e2e8f0;">${item.label}</span>
                `;
                legendContainer.appendChild(legendItem);
            });

            // Render heatmap on the right side
            renderScatterHeatmap(filteredData);
        }

        function renderScatterHeatmap(filteredData = data) {
            const container = document.getElementById('scatter-heatmap-container');
            container.innerHTML = '';

            const metricKey = document.getElementById('metric-select').value;
            const metricConfig = metricsConfig[metricKey];

            // Get grid dimensions from processed data
            const cols = gridLayout.cols;
            const rows = gridLayout.rows;
            const minX = gridLayout.minX;
            const minY = gridLayout.minY;

            // Calculate cell size to fit container (smaller than main heatmap)
            const containerWidth = container.offsetWidth || 500;
            const cellSize = Math.floor((containerWidth - 30) / cols);

            // Create grid
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            grid.style.gap = '2px';
            grid.style.justifyContent = 'center';

            // Create a map for quick lookup
            const tileMap = new Map();
            data.forEach(tile => {
                const key = `${tile.xtile},${tile.ytile}`;
                tileMap.set(key, tile);
            });

            const filteredIds = new Set(filteredData.map(t => t.tile_id));

            // Create cells
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const xtile = minX + col;
                    const ytile = minY + row;
                    const key = `${xtile},${ytile}`;
                    const tile = tileMap.get(key);

                    const cell = document.createElement('div');
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.borderRadius = '3px';
                    cell.style.transition = 'all 0.2s';

                    if (tile && filteredIds.has(tile.tile_id)) {
                        const value = tile[metricKey] || 0;
                        const color = getHeatmapColor(value, metricKey);
                        const isSelected = selectedTiles.has(tile.tile_id);

                        cell.style.backgroundColor = color;
                        cell.style.cursor = 'pointer';
                        cell.style.border = isSelected ? '3px solid #facc15' : '1px solid rgba(255,255,255,0.1)';
                        cell.style.boxShadow = isSelected ? '0 0 10px rgba(250, 204, 21, 0.6)' : 'none';
                        cell.title = `Tile ${tile.tile_id}: Click to select, Ctrl+Click for details`;

                        // Click to select, Ctrl+Click to open modal
                        cell.addEventListener('click', (e) => {
                            if (e.ctrlKey || e.metaKey) {
                                openTileDetailModal(tile);
                            } else {
                                toggleTileSelection(tile.tile_id, e);
                            }
                        });

                        // Hover effect
                        cell.addEventListener('mouseenter', () => {
                            if (!selectedTiles.has(tile.tile_id)) {
                                cell.style.transform = 'scale(1.1)';
                                cell.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                                cell.style.zIndex = '10';
                            }
                        });

                        cell.addEventListener('mouseleave', () => {
                            if (!selectedTiles.has(tile.tile_id)) {
                                cell.style.transform = 'scale(1)';
                                cell.style.boxShadow = 'none';
                                cell.style.zIndex = '1';
                            }
                        });

                        // Tooltip
                        cell.title = `Tile ${tile.tile_id}\n${metricConfig.label}: ${formatValue(value, metricConfig.isPercentage)}\nPosition: (${tile.xtile}, ${tile.ytile})`;
                    } else {
                        cell.style.backgroundColor = 'rgba(71, 85, 105, 0.2)';
                        cell.style.border = '1px solid rgba(71, 85, 105, 0.3)';
                    }

                    grid.appendChild(cell);
                }
            }

            container.appendChild(grid);
        }

        function renderScatterMap_UNUSED(filteredData = data) {
            const container = document.getElementById('scatter-map-container');
            
            if (!container) {
                console.error('Scatter map container not found!');
                return;
            }
            
            console.log('Container found:', container.offsetWidth, 'x', container.offsetHeight);
            
            // Remove existing map instance if it exists
            if (scatterMapInstance) {
                console.log('Removing old map instance');
                try {
                    scatterMapInstance.remove();
                    scatterMapInstance = null;
                } catch (e) {
                    console.warn('Map cleanup error:', e);
                }
            }
            
            // Clear container and ensure proper dimensions
            container.innerHTML = '';
            
            // Force container to be visible and have dimensions
            const parentSection = document.getElementById('scatter-section');
            if (parentSection && parentSection.style.display === 'none') {
                console.error('Scatter section is hidden!');
                return;
            }

            // Calculate bounds
            const lats = data.map(t => t.lat);
            const lons = data.map(t => t.lon);
            const centerLat = (Math.max(...lats) + Math.min(...lats)) / 2;
            const centerLon = (Math.max(...lons) + Math.min(...lons)) / 2;

            // Create map (same as spatial map)
            console.log('Creating Leaflet map...');
            try {
                scatterMapInstance = L.map(container).setView([centerLat, centerLon], 15);
                console.log('Map created successfully:', scatterMapInstance);

                // Add tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19,
                    opacity: 0.4
                }).addTo(scatterMapInstance);
                console.log('Tile layer added');
            } catch (error) {
                console.error('Error creating map:', error);
                return;
            }

            // Calculate tile size (same approach as spatial map)
            const sortedByX = [...data].sort((a, b) => a.xtile - b.xtile);
            const sortedByY = [...data].sort((a, b) => a.ytile - b.ytile);
            const cols = Math.max(...data.map(d => d.xtile)) - Math.min(...data.map(d => d.xtile)) + 1;
            const rows = Math.max(...data.map(d => d.ytile)) - Math.min(...data.map(d => d.ytile)) + 1;
            const lonSpan = Math.abs(sortedByX[sortedByX.length - 1].lon - sortedByX[0].lon) / cols;
            const latSpan = Math.abs(sortedByY[sortedByY.length - 1].lat - sortedByY[0].lat) / rows;

            const filteredIds = new Set(filteredData.map(t => t.tile_id));

            // Helper to get F1 color
            const getF1Color = (f1) => {
                if (f1 >= 0.9) return '#10b981';
                if (f1 >= 0.7) return '#3b82f6';
                if (f1 >= 0.5) return '#f59e0b';
                return '#ef4444';
            };

            // Draw tiles
            data.forEach(tile => {
                const f1 = tile.f1_score || 0;
                const color = getF1Color(f1);
                const isFiltered = filteredIds.has(tile.tile_id);
                const isSelected = selectedTiles.has(tile.tile_id);
                
                const bounds = [
                    [tile.lat - latSpan / 2, tile.lon - lonSpan / 2],
                    [tile.lat + latSpan / 2, tile.lon + lonSpan / 2]
                ];

                const rectangle = L.rectangle(bounds, {
                    color: isSelected ? '#facc15' : (isFiltered ? color : '#475569'),
                    fillColor: isFiltered ? color : '#1e293b',
                    fillOpacity: isFiltered ? 0.6 : 0.2,
                    weight: isSelected ? 4 : (isFiltered ? 2 : 1),
                    opacity: isSelected ? 1 : (isFiltered ? 0.8 : 0.4)
                }).addTo(scatterMapInstance);
                
                // Click to select
                rectangle.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleTileSelection(tile.tile_id, e.originalEvent);
                });
                
                // Popup
                const popupContent = `
                    <div style="font-family: sans-serif; min-width: 180px;">
                        <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: ${color};">
                            Tile ${tile.tile_id}
                        </div>
                        <div style="margin-bottom: 6px;">
                            <strong>F1:</strong> ${formatValue(tile.f1_score, true)}<br>
                            <strong>Precision:</strong> ${formatValue(tile.precision, true)}<br>
                            <strong>Recall:</strong> ${formatValue(tile.recall, true)}<br>
                            <strong>IoU:</strong> ${formatValue(tile.iou, true)}
                        </div>
                        <div style="font-size: 12px; color: #666;">
                            Position: (${tile.xtile}, ${tile.ytile})
                        </div>
                    </div>
                `;
                rectangle.bindPopup(popupContent);
                
                // Hover effect
                rectangle.on('mouseover', function() {
                    if (!isSelected) this.setStyle({ weight: 3, fillOpacity: 0.8 });
                });
                rectangle.on('mouseout', function() {
                    if (!isSelected) this.setStyle({ weight: isFiltered ? 2 : 1, fillOpacity: isFiltered ? 0.6 : 0.2 });
                });
            });
        }

        // Parallel Coordinates Functions
        function toggleParallelTileDropdown() {
            const dropdown = document.getElementById('parallel-tile-checkboxes');
            const btn = document.querySelector('.tile-filter-dropdown-btn');
            dropdown.classList.toggle('open');
            btn.classList.toggle('open');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const container = document.querySelector('.tile-filter-container');
            if (container && !container.contains(e.target)) {
                const dropdown = document.getElementById('parallel-tile-checkboxes');
                const btn = document.querySelector('.tile-filter-dropdown-btn');
                if (dropdown) dropdown.classList.remove('open');
                if (btn) btn.classList.remove('open');
            }
        });

        function initializeParallelTileFilter(filteredData) {
            const container = document.getElementById('parallel-tile-checkboxes');
            container.innerHTML = '';

            // Initialize selection with all tiles by default (only on first render)
            const currentTileIds = new Set(filteredData.map(t => `${t.xtile}_${t.ytile}`));
            
            if (parallelSelectedTiles.size === 0) {
                // First time - select all
                filteredData.forEach(tile => {
                    const tileId = `${tile.xtile}_${tile.ytile}`;
                    parallelSelectedTiles.add(tileId);
                });
            } else {
                // Remove tiles no longer in filtered data
                parallelSelectedTiles.forEach(tileId => {
                    if (!currentTileIds.has(tileId)) {
                        parallelSelectedTiles.delete(tileId);
                    }
                });
                // DON'T auto-add new tiles - preserve user's selection state
            }

            // Create search input container
            const searchContainer = document.createElement('div');
            searchContainer.className = 'tile-search-container';

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.className = 'tile-search-input';
            searchInput.placeholder = 'Search by tile ID or coordinates...';
            searchInput.id = 'parallel-tile-search';
            searchContainer.appendChild(searchInput);
            container.appendChild(searchContainer);

            // Create "Select All" checkbox
            const selectAllItem = document.createElement('div');
            selectAllItem.className = 'tile-checkbox-item select-all';

            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.id = 'parallel-select-all';
            selectAllCheckbox.checked = parallelSelectedTiles.size === filteredData.length;
            selectAllCheckbox.onchange = () => {
                if (selectAllCheckbox.checked) {
                    filteredData.forEach(tile => {
                        const tileId = `${tile.xtile}_${tile.ytile}`;
                        parallelSelectedTiles.add(tileId);
                        const checkbox = document.getElementById(`parallel-tile-${tileId}`);
                        if (checkbox) checkbox.checked = true;
                    });
                } else {
                    parallelSelectedTiles.clear();
                    const checkboxes = document.querySelectorAll('[id^="parallel-tile-"]');
                    checkboxes.forEach(cb => cb.checked = false);
                }
                updateParallelSelectedCount();
                renderParallelCoordinates(filteredData);
            };

            const selectAllLabel = document.createElement('label');
            selectAllLabel.htmlFor = 'parallel-select-all';
            selectAllLabel.textContent = 'Select All';

            selectAllItem.appendChild(selectAllCheckbox);
            selectAllItem.appendChild(selectAllLabel);
            container.appendChild(selectAllItem);

            // Create container for scrollable items
            const scrollableContainer = document.createElement('div');
            scrollableContainer.id = 'parallel-tile-items';
            container.appendChild(scrollableContainer);

            // Create individual tile checkboxes
            filteredData.forEach(tile => {
                const tileId = `${tile.xtile}_${tile.ytile}`;
                const isChecked = parallelSelectedTiles.has(tileId);

                const item = document.createElement('div');
                item.className = 'tile-checkbox-item';
                item.dataset.tileId = tile.tile_id;
                item.dataset.coords = `${tile.xtile},${tile.ytile}`;
                item.dataset.searchText = `${tile.tile_id} ${tile.xtile} ${tile.ytile}`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `parallel-tile-${tileId}`;
                checkbox.checked = isChecked;
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        parallelSelectedTiles.add(tileId);
                    } else {
                        parallelSelectedTiles.delete(tileId);
                    }
                    const selectAllCb = document.getElementById('parallel-select-all');
                    if (selectAllCb) {
                        const visibleItems = Array.from(scrollableContainer.querySelectorAll('.tile-checkbox-item[style*="display: flex"], .tile-checkbox-item:not([style*="display: none"])'));
                        selectAllCb.checked = visibleItems.length > 0 && visibleItems.every(item => {
                            const cb = item.querySelector('input[type="checkbox"]');
                            return cb && cb.checked;
                        });
                    }
                    updateParallelSelectedCount();
                    renderParallelCoordinates(filteredData);
                };

                const label = document.createElement('label');
                label.htmlFor = `parallel-tile-${tileId}`;
                label.innerHTML = `<span style="color: #60a5fa; font-weight: 600;">#${tile.tile_id}</span> <span style="color: #94a3b8;">(${tile.xtile}, ${tile.ytile})</span>`;

                item.appendChild(checkbox);
                item.appendChild(label);
                scrollableContainer.appendChild(item);
            });

            // Add search functionality
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                const items = scrollableContainer.querySelectorAll('.tile-checkbox-item');
                
                items.forEach(item => {
                    const searchText = item.dataset.searchText.toLowerCase();
                    if (searchTerm === '' || searchText.includes(searchTerm)) {
                        item.style.display = 'flex';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });

            updateParallelSelectedCount();
        }

        function updateParallelSelectedCount() {
            const countElem = document.getElementById('parallel-selected-count');
            const filtered = getFilteredData();
            countElem.textContent = `${parallelSelectedTiles.size}/${filtered.length}`;
        }

        function renderParallelCoordinates(filteredData = data) {
            const container = document.getElementById('parallel-plot');
            
            // Initialize tile filter only if not already initialized
            const checkboxContainer = document.getElementById('parallel-tile-checkboxes');
            if (checkboxContainer && checkboxContainer.children.length === 0) {
                initializeParallelTileFilter(filteredData);
            } else {
                // Just update the count and checkboxes state without re-creating them
                updateParallelSelectedCount();
            }

            container.innerHTML = '';

            // Filter by selected tiles
            const displayData = filteredData.filter(tile => {
                const tileId = `${tile.xtile}_${tile.ytile}`;
                return parallelSelectedTiles.has(tileId);
            });

            if (displayData.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #94a3b8;">No tiles selected. Click "Filter Tiles" to select tiles.</div>';
                return;
            }

            // Define metrics/dimensions
            const dimensions = [
                { key: 'f1_score', label: 'F1 Score', range: [0, 1] },
                { key: 'precision', label: 'Precision', range: [0, 1] },
                { key: 'recall', label: 'Recall', range: [0, 1] },
                { key: 'iou', label: 'IoU', range: [0, 1] },
                { key: 'tp_length_m', label: 'TP (m)', range: null },
                { key: 'fp_length_m', label: 'FP (m)', range: null },
                { key: 'fn_length_m', label: 'FN (m)', range: null }
            ];

            // Calculate auto ranges for length metrics
            dimensions.forEach(dim => {
                if (!dim.range) {
                    const values = displayData.map(d => d[dim.key] || 0);
                    dim.range = [Math.min(...values), Math.max(...values)];
                }
            });

            // SVG setup
            const width = container.clientWidth || 1200;
            const height = 550;
            const margin = { top: 40, right: 60, bottom: 40, left: 60 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.display = 'block';
            container.appendChild(svg);

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Calculate axis positions
            const axisSpacing = plotWidth / (dimensions.length - 1);
            const xPositions = dimensions.map((d, i) => i * axisSpacing);

            // Create scale functions
            const scales = dimensions.map(dim => {
                const [min, max] = dim.range;
                return (value) => {
                    const normalized = (value - min) / (max - min || 1);
                    return plotHeight - (normalized * plotHeight);
                };
            });

            // Color scale
            const getLineColor = (f1) => {
                if (f1 >= 0.9) return '#10b981';
                if (f1 >= 0.7) return '#3b82f6';
                if (f1 >= 0.5) return '#f59e0b';
                return '#ef4444';
            };

            // Draw axes
            dimensions.forEach((dim, i) => {
                const x = xPositions[i];

                // Axis line
                const axisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                axisLine.setAttribute('x1', x);
                axisLine.setAttribute('y1', 0);
                axisLine.setAttribute('x2', x);
                axisLine.setAttribute('y2', plotHeight);
                axisLine.setAttribute('stroke', '#64748b');
                axisLine.setAttribute('stroke-width', 2);
                axisLine.classList.add('parallel-axis');
                g.appendChild(axisLine);

                // Axis label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', -15);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', '#e2e8f0');
                label.setAttribute('font-size', '13px');
                label.setAttribute('font-weight', '600');
                label.textContent = dim.label;
                g.appendChild(label);

                // Tick marks
                const numTicks = 5;
                for (let j = 0; j <= numTicks; j++) {
                    const t = j / numTicks;
                    const y = plotHeight - (t * plotHeight);
                    const value = dim.range[0] + t * (dim.range[1] - dim.range[0]);

                    // Tick mark
                    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tick.setAttribute('x1', x - 5);
                    tick.setAttribute('y1', y);
                    tick.setAttribute('x2', x + 5);
                    tick.setAttribute('y2', y);
                    tick.setAttribute('stroke', '#94a3b8');
                    tick.setAttribute('stroke-width', 1);
                    g.appendChild(tick);

                    // Tick label
                    const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    tickLabel.setAttribute('x', x + (i === 0 ? -12 : i === dimensions.length - 1 ? 12 : 0));
                    tickLabel.setAttribute('y', y);
                    tickLabel.setAttribute('text-anchor', i === 0 ? 'end' : i === dimensions.length - 1 ? 'start' : 'middle');
                    tickLabel.setAttribute('dominant-baseline', 'middle');
                    tickLabel.setAttribute('fill', '#94a3b8');
                    tickLabel.setAttribute('font-size', '10px');
                    tickLabel.textContent = value.toFixed(value < 10 ? 2 : 0);
                    g.appendChild(tickLabel);
                }
            });

            // Draw polylines
            const lines = [];
            displayData.forEach(tile => {
                const f1 = tile.f1_score || 0;
                const color = getLineColor(f1);

                let pathData = '';
                dimensions.forEach((dim, i) => {
                    const x = xPositions[i];
                    const value = tile[dim.key] || 0;
                    const y = scales[i](value);
                    pathData += (i === 0 ? 'M' : 'L') + x + ',' + y;
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', color);
                path.classList.add('parallel-line');
                path.dataset.tileId = tile.tile_id;
                path.dataset.xtile = tile.xtile;
                path.dataset.ytile = tile.ytile;
                path.style.cursor = 'pointer';
                
                // Add tooltip hint
                const titleElem = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                titleElem.textContent = `Tile ${tile.tile_id}: Click to select, Ctrl+Click for details`;
                path.appendChild(titleElem);
                
                // Highlight if selected
                const isSelected = selectedTiles.has(tile.tile_id);
                if (isSelected) {
                    path.classList.add('highlighted');
                    path.setAttribute('stroke', '#facc15');
                    path.setAttribute('stroke-width', '3');
                }

                // Click to select, Ctrl+Click to open modal
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (e.ctrlKey || e.metaKey) {
                        openTileDetailModal(tile);
                    } else {
                        toggleTileSelection(tile.tile_id, e);
                    }
                });

                // Hover events
                path.addEventListener('mouseenter', () => {
                    if (!isSelected) {
                        lines.forEach(l => {
                            if (!selectedTiles.has(parseInt(l.dataset.tileId))) {
                                l.classList.add('dimmed');
                            }
                        });
                        path.classList.remove('dimmed');
                        path.classList.add('highlighted');
                    }
                });

                path.addEventListener('mouseleave', () => {
                    if (!isSelected) {
                        lines.forEach(l => {
                            l.classList.remove('dimmed');
                            if (!selectedTiles.has(parseInt(l.dataset.tileId))) {
                                l.classList.remove('highlighted');
                            }
                        });
                    }
                });

                path.addEventListener('mousemove', (e) => {
                    const rect = svg.getBoundingClientRect();
                    const tooltipX = e.clientX - rect.left + 10;
                    const tooltipY = e.clientY - rect.top - 10;

                    let tooltip = document.getElementById('parallel-tooltip');
                    if (!tooltip) {
                        tooltip = document.createElement('div');
                        tooltip.id = 'parallel-tooltip';
                        tooltip.style.position = 'absolute';
                        tooltip.style.background = 'rgba(15, 23, 42, 0.95)';
                        tooltip.style.color = '#e2e8f0';
                        tooltip.style.padding = '8px 12px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '12px';
                        tooltip.style.pointerEvents = 'none';
                        tooltip.style.zIndex = '1000';
                        tooltip.style.border = '1px solid rgba(59, 130, 246, 0.3)';
                        container.appendChild(tooltip);
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 4px; color: ${color};">Tile (${tile.xtile}, ${tile.ytile})</div>
                        <div>F1: ${(f1 * 100).toFixed(1)}%</div>
                        <div>Precision: ${((tile.precision || 0) * 100).toFixed(1)}%</div>
                        <div>Recall: ${((tile.recall || 0) * 100).toFixed(1)}%</div>
                        <div>IoU: ${((tile.iou || 0) * 100).toFixed(1)}%</div>
                        <div>TP: ${(tile.tp_length_m || 0).toFixed(1)}m</div>
                        <div>FP: ${(tile.fp_length_m || 0).toFixed(1)}m</div>
                        <div>FN: ${(tile.fn_length_m || 0).toFixed(1)}m</div>
                    `;
                });

                g.appendChild(path);
                lines.push(path);
            });

            // Remove tooltip on mouse leave from container
            container.addEventListener('mouseleave', () => {
                const tooltip = document.getElementById('parallel-tooltip');
                if (tooltip) tooltip.style.display = 'none';
            });
        }

        function computeQuartiles(values) {
            if (values.length === 0) return null;

            const sorted = [...values].sort((a, b) => a - b);
            const n = sorted.length;

            const median = n % 2 === 0 
                ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 
                : sorted[Math.floor(n / 2)];

            const q1Index = Math.floor(n * 0.25);
            const q3Index = Math.floor(n * 0.75);
            
            const q1 = sorted[q1Index];
            const q3 = sorted[q3Index];
            const iqr = q3 - q1;

            const min = sorted[0];
            const max = sorted[n - 1];

            // Identify outliers
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            const outliers = sorted.filter(v => v < lowerBound || v > upperBound);

            return { min, q1, median, q3, max, iqr, outliers, lowerBound, upperBound };
        }

        function renderDistributions(filteredData = data) {
            const container = document.getElementById('distributions-container');
            if (!container) return;

            container.innerHTML = '';

            const metrics = ['f1_score', 'precision', 'recall', 'iou'];
            const width = 1100;
            const height = 100;
            const margin = { top: 10, right: 200, bottom: 40, left: 150 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            metrics.forEach(metric => {
                // Extract values from filtered data
                const values = filteredData.map(tile => (tile[metric] || 0) * 100); // Convert to percentage
                const stats = computeQuartiles(values);
                if (!stats) return;

                // Create container for this metric
                const row = document.createElement('div');
                row.className = 'boxplot-row';

                const label = document.createElement('div');
                label.className = 'boxplot-label';
                
                // Add color indicator
                const colorDot = document.createElement('span');
                colorDot.style.cssText = 'width: 12px; height: 12px; border-radius: 50%; display: inline-block;';
                if (metric === 'f1_score') colorDot.style.background = '#3b82f6';
                else if (metric === 'precision') colorDot.style.background = '#10b981';
                else if (metric === 'recall') colorDot.style.background = '#a855f7';
                else if (metric === 'iou') colorDot.style.background = '#f97316';
                
                label.appendChild(colorDot);
                label.appendChild(document.createTextNode(metricsConfig[metric]?.label || metric));
                row.appendChild(label);

                // Create SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('class', 'boxplot-svg');
                row.appendChild(svg);

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
                svg.appendChild(g);

                // Scale (0-100%)
                const xScale = (val) => (val / 100) * plotWidth;
                const centerY = plotHeight / 2;

                // Draw background
                const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bgRect.setAttribute('x', 0);
                bgRect.setAttribute('y', 0);
                bgRect.setAttribute('width', plotWidth);
                bgRect.setAttribute('height', plotHeight);
                bgRect.setAttribute('fill', 'rgba(15, 23, 42, 0.3)');
                bgRect.setAttribute('stroke', '#334155');
                bgRect.setAttribute('stroke-width', 1);
                bgRect.setAttribute('rx', 4);
                g.appendChild(bgRect);

                // Draw axis line
                const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                axis.setAttribute('x1', 0);
                axis.setAttribute('y1', centerY);
                axis.setAttribute('x2', plotWidth);
                axis.setAttribute('y2', centerY);
                axis.setAttribute('stroke', '#475569');
                axis.setAttribute('stroke-width', 1);
                g.appendChild(axis);

                // Draw whiskers
                const whiskerLeft = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                whiskerLeft.setAttribute('x1', xScale(Math.max(stats.min, stats.lowerBound)));
                whiskerLeft.setAttribute('y1', centerY);
                whiskerLeft.setAttribute('x2', xScale(stats.q1));
                whiskerLeft.setAttribute('y2', centerY);
                whiskerLeft.setAttribute('stroke', '#10b981');
                whiskerLeft.setAttribute('stroke-width', 2);
                g.appendChild(whiskerLeft);

                const whiskerRight = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                whiskerRight.setAttribute('x1', xScale(stats.q3));
                whiskerRight.setAttribute('y1', centerY);
                whiskerRight.setAttribute('x2', xScale(Math.min(stats.max, stats.upperBound)));
                whiskerRight.setAttribute('y2', centerY);
                whiskerRight.setAttribute('stroke', '#10b981');
                whiskerRight.setAttribute('stroke-width', 2);
                g.appendChild(whiskerRight);

                // Draw whisker end caps
                const capSize = 8;
                const leftCap = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                leftCap.setAttribute('x1', xScale(Math.max(stats.min, stats.lowerBound)));
                leftCap.setAttribute('y1', centerY - capSize);
                leftCap.setAttribute('x2', xScale(Math.max(stats.min, stats.lowerBound)));
                leftCap.setAttribute('y2', centerY + capSize);
                leftCap.setAttribute('stroke', '#10b981');
                leftCap.setAttribute('stroke-width', 2);
                g.appendChild(leftCap);

                const rightCap = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                rightCap.setAttribute('x1', xScale(Math.min(stats.max, stats.upperBound)));
                rightCap.setAttribute('y1', centerY - capSize);
                rightCap.setAttribute('x2', xScale(Math.min(stats.max, stats.upperBound)));
                rightCap.setAttribute('y2', centerY + capSize);
                rightCap.setAttribute('stroke', '#10b981');
                rightCap.setAttribute('stroke-width', 2);
                g.appendChild(rightCap);

                // Draw box (Q1 to Q3)
                const boxHeight = 30;
                const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                box.setAttribute('x', xScale(stats.q1));
                box.setAttribute('y', centerY - boxHeight / 2);
                box.setAttribute('width', xScale(stats.q3) - xScale(stats.q1));
                box.setAttribute('height', boxHeight);
                box.setAttribute('fill', 'rgba(16, 185, 129, 0.3)');
                box.setAttribute('stroke', '#10b981');
                box.setAttribute('stroke-width', 2);
                box.setAttribute('rx', 4);
                g.appendChild(box);

                // Draw median line
                const medianLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                medianLine.setAttribute('x1', xScale(stats.median));
                medianLine.setAttribute('y1', centerY - boxHeight / 2);
                medianLine.setAttribute('x2', xScale(stats.median));
                medianLine.setAttribute('y2', centerY + boxHeight / 2);
                medianLine.setAttribute('stroke', '#ef4444');
                medianLine.setAttribute('stroke-width', 3);
                g.appendChild(medianLine);

                // Draw outliers
                stats.outliers.forEach(outlier => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', xScale(outlier));
                    circle.setAttribute('cy', centerY);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('fill', '#ef4444');
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', 1.5);
                    g.appendChild(circle);
                });

                // Add tick labels every 20%
                for (let i = 0; i <= 100; i += 20) {
                    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tick.setAttribute('x1', xScale(i));
                    tick.setAttribute('y1', plotHeight);
                    tick.setAttribute('x2', xScale(i));
                    tick.setAttribute('y2', plotHeight + 6);
                    tick.setAttribute('stroke', '#64748b');
                    tick.setAttribute('stroke-width', 1);
                    g.appendChild(tick);

                    const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    tickLabel.setAttribute('x', xScale(i));
                    tickLabel.setAttribute('y', plotHeight + 20);
                    tickLabel.setAttribute('text-anchor', 'middle');
                    tickLabel.setAttribute('fill', '#94a3b8');
                    tickLabel.setAttribute('font-size', '11px');
                    tickLabel.textContent = `${i}%`;
                    g.appendChild(tickLabel);
                }

                // Add statistics text (Q1, Median, Q3)
                const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statsText.setAttribute('x', plotWidth + 10);
                statsText.setAttribute('y', centerY);
                statsText.setAttribute('dominant-baseline', 'middle');
                statsText.setAttribute('fill', '#cbd5e1');
                statsText.setAttribute('font-size', '11px');
                statsText.innerHTML = `Q1: ${stats.q1.toFixed(1)}% | Med: ${stats.median.toFixed(1)}% | Q3: ${stats.q3.toFixed(1)}%`;
                statsText.textContent = `Q1: ${stats.q1.toFixed(1)}% | Med: ${stats.median.toFixed(1)}% | Q3: ${stats.q3.toFixed(1)}%`;
                g.appendChild(statsText);

                // Add tooltip to box
                box.style.cursor = 'pointer';
                let tooltip = null;
                box.addEventListener('mouseenter', (e) => {
                    box.setAttribute('fill', 'rgba(16, 185, 129, 0.5)');
                    
                    tooltip = document.createElement('div');
                    tooltip.style.position = 'fixed';
                    tooltip.style.left = `${e.clientX + 12}px`;
                    tooltip.style.top = `${e.clientY - 12}px`;
                    tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                    tooltip.style.color = '#fff';
                    tooltip.style.padding = '12px 16px';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.fontSize = '12px';
                    tooltip.style.zIndex = '10000';
                    tooltip.style.pointerEvents = 'none';
                    tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                    tooltip.style.border = '2px solid #10b981';
                    tooltip.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 6px; color: #10b981;">${metricsConfig[metric].label}</div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Min:</span> <strong>${stats.min.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Q1:</span> <strong>${stats.q1.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Median:</span> <strong>${stats.median.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Q3:</span> <strong>${stats.q3.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Max:</span> <strong>${stats.max.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">IQR:</span> <strong>${stats.iqr.toFixed(1)}%</strong></div>
                        <div style="margin: 3px 0;"><span style="color: #94a3b8;">Outliers:</span> <strong>${stats.outliers.length}</strong></div>
                    `;
                    document.body.appendChild(tooltip);
                });

                box.addEventListener('mousemove', (e) => {
                    if (tooltip) {
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                    }
                });

                box.addEventListener('mouseleave', () => {
                    box.setAttribute('fill', 'rgba(16, 185, 129, 0.3)');
                    
                    if (tooltip) {
                        document.body.removeChild(tooltip);
                        tooltip = null;
                    }
                });

                container.appendChild(row);
            });
        }

        function renderComposition(filteredData = data) {
            const container = document.getElementById('composition-container');
            if (!container) return;

            container.innerHTML = '';

            // Sort filtered data by F1 score and take top 50
            const sorted = [...filteredData]
                .sort((a, b) => (b.f1_score || 0) - (a.f1_score || 0))
                .slice(0, 50);

            sorted.forEach(tile => {
                const tp = tile.tp_length_m || 0;
                const fp = tile.fp_length_m || 0;
                const fn = tile.fn_length_m || 0;
                const total = tp + fp + fn;

                if (total === 0) return;

                // Calculate percentages
                const tpPct = (tp / total) * 100;
                const fpPct = (fp / total) * 100;
                const fnPct = (fn / total) * 100;

                // Create row
                const row = document.createElement('div');
                row.className = 'composition-bar-row';

                // Label
                const label = document.createElement('div');
                label.className = 'composition-label';
                label.textContent = tile.tile_id;
                row.appendChild(label);

                // Stacked bar
                const bar = document.createElement('div');
                bar.className = 'composition-bar';

                // TP segment
                if (tpPct > 0) {
                    const tpSegment = document.createElement('div');
                    tpSegment.className = 'composition-segment tp';
                    tpSegment.style.width = `${tpPct}%`;
                    
                    let tooltip = null;
                    tpSegment.addEventListener('mouseenter', (e) => {
                        tooltip = document.createElement('div');
                        tooltip.style.position = 'fixed';
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                        tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                        tooltip.style.color = '#fff';
                        tooltip.style.padding = '10px 14px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '12px';
                        tooltip.style.zIndex = '10000';
                        tooltip.style.pointerEvents = 'none';
                        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                        tooltip.style.border = '2px solid #10b981';
                        tooltip.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 4px; color: #10b981;">True Positive</div>
                            <div><strong>${tp.toFixed(1)} m</strong> (${tpPct.toFixed(1)}%)</div>
                        `;
                        document.body.appendChild(tooltip);
                    });

                    tpSegment.addEventListener('mousemove', (e) => {
                        if (tooltip) {
                            tooltip.style.left = `${e.clientX + 12}px`;
                            tooltip.style.top = `${e.clientY - 12}px`;
                        }
                    });

                    tpSegment.addEventListener('mouseleave', () => {
                        if (tooltip) {
                            document.body.removeChild(tooltip);
                            tooltip = null;
                        }
                    });

                    bar.appendChild(tpSegment);
                }

                // FP segment
                if (fpPct > 0) {
                    const fpSegment = document.createElement('div');
                    fpSegment.className = 'composition-segment fp';
                    fpSegment.style.width = `${fpPct}%`;
                    
                    let tooltip = null;
                    fpSegment.addEventListener('mouseenter', (e) => {
                        tooltip = document.createElement('div');
                        tooltip.style.position = 'fixed';
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                        tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                        tooltip.style.color = '#fff';
                        tooltip.style.padding = '10px 14px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '12px';
                        tooltip.style.zIndex = '10000';
                        tooltip.style.pointerEvents = 'none';
                        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                        tooltip.style.border = '2px solid #ef4444';
                        tooltip.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 4px; color: #ef4444;">False Positive</div>
                            <div><strong>${fp.toFixed(1)} m</strong> (${fpPct.toFixed(1)}%)</div>
                        `;
                        document.body.appendChild(tooltip);
                    });

                    fpSegment.addEventListener('mousemove', (e) => {
                        if (tooltip) {
                            tooltip.style.left = `${e.clientX + 12}px`;
                            tooltip.style.top = `${e.clientY - 12}px`;
                        }
                    });

                    fpSegment.addEventListener('mouseleave', () => {
                        if (tooltip) {
                            document.body.removeChild(tooltip);
                            tooltip = null;
                        }
                    });

                    bar.appendChild(fpSegment);
                }

                // FN segment
                if (fnPct > 0) {
                    const fnSegment = document.createElement('div');
                    fnSegment.className = 'composition-segment fn';
                    fnSegment.style.width = `${fnPct}%`;
                    
                    let tooltip = null;
                    fnSegment.addEventListener('mouseenter', (e) => {
                        tooltip = document.createElement('div');
                        tooltip.style.position = 'fixed';
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                        tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                        tooltip.style.color = '#fff';
                        tooltip.style.padding = '10px 14px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '12px';
                        tooltip.style.zIndex = '10000';
                        tooltip.style.pointerEvents = 'none';
                        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                        tooltip.style.border = '2px solid #f59e0b';
                        tooltip.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 4px; color: #f59e0b;">False Negative</div>
                            <div><strong>${fn.toFixed(1)} m</strong> (${fnPct.toFixed(1)}%)</div>
                        `;
                        document.body.appendChild(tooltip);
                    });

                    fnSegment.addEventListener('mousemove', (e) => {
                        if (tooltip) {
                            tooltip.style.left = `${e.clientX + 12}px`;
                            tooltip.style.top = `${e.clientY - 12}px`;
                        }
                    });

                    fnSegment.addEventListener('mouseleave', () => {
                        if (tooltip) {
                            document.body.removeChild(tooltip);
                            tooltip = null;
                        }
                    });

                    bar.appendChild(fnSegment);
                }

                row.appendChild(bar);

                // F1 score value on right
                const value = document.createElement('div');
                value.className = 'composition-value';
                value.textContent = `F1: ${((tile.f1_score || 0) * 100).toFixed(1)}%`;
                row.appendChild(value);

                container.appendChild(row);
            });
        }

        function computePearsonCorrelation(x, y) {
            const n = x.length;
            if (n === 0 || n !== y.length) return 0;

            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            return denominator === 0 ? 0 : numerator / denominator;
        }

        function renderCorrelation(filteredData = data) {
            const container = document.getElementById('correlation-container');
            if (!container) return;

            container.innerHTML = '';

            // Define metrics to correlate
            const metrics = [
                { key: 'f1_score', label: 'F1' },
                { key: 'precision', label: 'Precision' },
                { key: 'recall', label: 'Recall' },
                { key: 'iou', label: 'IoU' },
                { key: 'tp_length_m', label: 'TP (m)' },
                { key: 'fp_length_m', label: 'FP (m)' },
                { key: 'fn_length_m', label: 'FN (m)' }
            ];

            const n = metrics.length;

            // Compute correlation matrix from filtered data
            const correlations = [];
            for (let i = 0; i < n; i++) {
                correlations[i] = [];
                for (let j = 0; j < n; j++) {
                    const xValues = filteredData.map(tile => tile[metrics[i].key] || 0);
                    const yValues = filteredData.map(tile => tile[metrics[j].key] || 0);
                    correlations[i][j] = computePearsonCorrelation(xValues, yValues);
                }
            }

            // Create grid
            const grid = document.createElement('div');
            grid.className = 'correlation-grid';
            grid.style.gridTemplateColumns = `repeat(${n + 1}, auto)`;

            // Top-left empty cell
            const emptyCell = document.createElement('div');
            emptyCell.className = 'correlation-cell header';
            grid.appendChild(emptyCell);

            // Column headers
            for (let j = 0; j < n; j++) {
                const header = document.createElement('div');
                header.className = 'correlation-cell header';
                header.textContent = metrics[j].label;
                grid.appendChild(header);
            }

            // Rows
            for (let i = 0; i < n; i++) {
                // Row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'correlation-cell header';
                rowHeader.textContent = metrics[i].label;
                grid.appendChild(rowHeader);

                // Correlation cells
                for (let j = 0; j < n; j++) {
                    const corr = correlations[i][j];
                    const cell = document.createElement('div');
                    cell.className = 'correlation-cell';

                    // Color based on correlation value
                    // Blue for positive, red for negative, white for zero
                    let bgColor;
                    if (corr > 0) {
                        const intensity = Math.min(255, Math.floor(corr * 200));
                        bgColor = `rgb(${Math.floor((1 - corr) * 30)}, ${Math.floor((1 - corr) * 100 + 100)}, ${intensity})`;
                    } else if (corr < 0) {
                        const intensity = Math.min(255, Math.floor(-corr * 200));
                        bgColor = `rgb(${intensity}, ${Math.floor((1 + corr) * 100)}, ${Math.floor((1 + corr) * 100)})`;
                    } else {
                        bgColor = '#334155';
                    }

                    cell.style.background = bgColor;
                    cell.style.color = Math.abs(corr) > 0.5 ? '#fff' : '#cbd5e1';

                    const valueDiv = document.createElement('div');
                    valueDiv.className = 'correlation-value';
                    valueDiv.textContent = corr.toFixed(2);
                    cell.appendChild(valueDiv);

                    // Tooltip
                    let tooltip = null;
                    cell.addEventListener('mouseenter', (e) => {
                        tooltip = document.createElement('div');
                        tooltip.style.position = 'fixed';
                        tooltip.style.left = `${e.clientX + 12}px`;
                        tooltip.style.top = `${e.clientY - 12}px`;
                        tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                        tooltip.style.color = '#fff';
                        tooltip.style.padding = '10px 14px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '12px';
                        tooltip.style.zIndex = '10000';
                        tooltip.style.pointerEvents = 'none';
                        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                        tooltip.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 4px;">${metrics[i].label} vs ${metrics[j].label}</div>
                            <div>Pearson r = ${corr.toFixed(3)}</div>
                            <div style="font-size: 10px; color: #94a3b8; margin-top: 4px;">
                                ${Math.abs(corr) > 0.7 ? 'Strong' : Math.abs(corr) > 0.4 ? 'Moderate' : 'Weak'} 
                                ${corr > 0 ? 'positive' : corr < 0 ? 'negative' : 'no'} correlation
                            </div>
                        `;
                        document.body.appendChild(tooltip);
                    });

                    cell.addEventListener('mousemove', (e) => {
                        if (tooltip) {
                            tooltip.style.left = `${e.clientX + 12}px`;
                            tooltip.style.top = `${e.clientY - 12}px`;
                        }
                    });

                    cell.addEventListener('mouseleave', () => {
                        if (tooltip) {
                            document.body.removeChild(tooltip);
                            tooltip = null;
                        }
                    });

                    grid.appendChild(cell);
                }
            }

            container.appendChild(grid);
        }

        function renderBucketMap(container, bucket, allData) {
            // Calculate bounds for all tiles
            const lats = allData.map(t => t.lat);
            const lons = allData.map(t => t.lon);
            const centerLat = (Math.max(...lats) + Math.min(...lats)) / 2;
            const centerLon = (Math.max(...lons) + Math.min(...lons)) / 2;

            // Create map
            const bucketMap = L.map(container, {
                zoomControl: false,
                attributionControl: false
            }).setView([centerLat, centerLon], 15);

            // Add base map with lower opacity
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                opacity: 0.3
            }).addTo(bucketMap);

            // Calculate tile size from grid
            const cols = Math.max(...allData.map(d => d.xtile)) - Math.min(...allData.map(d => d.xtile)) + 1;
            const rows = Math.max(...allData.map(d => d.ytile)) - Math.min(...allData.map(d => d.ytile)) + 1;
            const maxLat = Math.max(...lats);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lons);
            const minLon = Math.min(...lons);
            const lonSpan = (maxLon - minLon) / cols;
            const latSpan = (maxLat - minLat) / rows;

            const tileIds = new Set(bucket.tiles.map(t => t.tile_id));

            // Draw all tiles with appropriate styling
            allData.forEach(tile => {
                const tileLat = tile.lat;
                const tileLon = tile.lon;
                const bounds = [
                    [tileLat - latSpan / 2, tileLon - lonSpan / 2],
                    [tileLat + latSpan / 2, tileLon + lonSpan / 2]
                ];

                const isInBucket = tileIds.has(tile.tile_id);
                const f1 = tile.f1_score || 0;

                const rectangle = L.rectangle(bounds, {
                    color: isInBucket ? bucket.color : '#334155',
                    weight: isInBucket ? 2 : 1,
                    fillColor: isInBucket ? bucket.color : '#1e293b',
                    fillOpacity: isInBucket ? (0.3 + f1 * 0.5) : 0.1
                }).addTo(bucketMap);

                if (isInBucket) {
                    rectangle.bindPopup(`
                        <div style="font-size: 12px;">
                            <strong style="color: ${bucket.color};">Tile ${tile.tile_id}</strong><br>
                            F1: ${(f1 * 100).toFixed(1)}%<br>
                            Precision: ${((tile.precision || 0) * 100).toFixed(1)}%<br>
                            Recall: ${((tile.recall || 0) * 100).toFixed(1)}%
                        </div>
                    `);
                }
            });

            // Fit bounds
            const bucketBounds = bucket.tiles.map(t => {
                return [
                    [t.lat - latSpan / 2, t.lon - lonSpan / 2],
                    [t.lat + latSpan / 2, t.lon + lonSpan / 2]
                ];
            }).flat();
            
            if (bucketBounds.length > 0) {
                bucketMap.fitBounds(bucketBounds, { padding: [20, 20] });
            }
        }

        function renderBuckets(filteredData = data) {
            const container = document.getElementById('buckets-container');
            if (!container) return;

            container.innerHTML = '';

            // Define buckets
            const buckets = [
                { name: 'Excellent', min: 0.90, max: 1.01, color: '#10b981', tiles: [] },
                { name: 'Good', min: 0.70, max: 0.90, color: '#3b82f6', tiles: [] },
                { name: 'Fair', min: 0.50, max: 0.70, color: '#f59e0b', tiles: [] },
                { name: 'Poor', min: 0.0, max: 0.50, color: '#ef4444', tiles: [] }
            ];

            // Assign filtered tiles to buckets
            filteredData.forEach(tile => {
                const f1 = tile.f1_score || 0;
                for (const bucket of buckets) {
                    if (f1 >= bucket.min && f1 < bucket.max) {
                        bucket.tiles.push(tile);
                        break;
                    }
                }
            });

            // Create grid container
            const bucketsGrid = document.createElement('div');
            bucketsGrid.className = 'buckets-grid';

            buckets.forEach(bucket => {
                // Calculate bucket stats
                const avgF1 = bucket.tiles.length > 0
                    ? bucket.tiles.reduce((sum, t) => sum + (t.f1_score || 0), 0) / bucket.tiles.length
                    : 0;
                const avgPrecision = bucket.tiles.length > 0
                    ? bucket.tiles.reduce((sum, t) => sum + (t.precision || 0), 0) / bucket.tiles.length
                    : 0;
                const avgRecall = bucket.tiles.length > 0
                    ? bucket.tiles.reduce((sum, t) => sum + (t.recall || 0), 0) / bucket.tiles.length
                    : 0;

                // Create bucket card
                const card = document.createElement('div');
                card.className = 'bucket-card';
                card.style.borderColor = bucket.color + '40';

                // Header
                const header = document.createElement('div');
                header.className = 'bucket-header';

                const title = document.createElement('div');
                title.className = 'bucket-title';
                title.style.color = bucket.color;
                title.textContent = bucket.name;

                const count = document.createElement('div');
                count.className = 'bucket-count';
                count.textContent = `${bucket.tiles.length} tiles (${((bucket.tiles.length / 96) * 100).toFixed(1)}%)`;

                header.appendChild(title);
                header.appendChild(count);
                card.appendChild(header);

                // Range description
                if (bucket.tiles.length > 0) {
                    const rangeDesc = document.createElement('div');
                    rangeDesc.style.fontSize = '11px';
                    rangeDesc.style.color = '#94a3b8';
                    rangeDesc.style.marginBottom = '10px';
                    rangeDesc.style.textAlign = 'center';
                    const minPct = Math.floor(bucket.min * 100);
                    const maxPct = bucket.max > 1 ? 100 : Math.floor(bucket.max * 100);
                    rangeDesc.textContent = `F1 Score: ${minPct}% - ${maxPct}%`;
                    card.appendChild(rangeDesc);

                    // Toggle buttons
                    const toggleContainer = document.createElement('div');
                    toggleContainer.className = 'bucket-toggle';
                    
                    const gridBtn = document.createElement('button');
                    gridBtn.className = 'bucket-toggle-btn active';
                    gridBtn.textContent = 'Grid';
                    gridBtn.dataset.bucketName = bucket.name;
                    
                    const mapBtn = document.createElement('button');
                    mapBtn.className = 'bucket-toggle-btn';
                    mapBtn.textContent = 'Map';
                    mapBtn.dataset.bucketName = bucket.name;
                    
                    toggleContainer.appendChild(gridBtn);
                    toggleContainer.appendChild(mapBtn);
                    card.appendChild(toggleContainer);
                }

                // Mini heatmap grid (12×8)
                const grid = document.createElement('div');
                grid.className = 'bucket-grid';

                // Create set of tile IDs in this bucket for quick lookup
                const tileIds = new Set(bucket.tiles.map(t => t.tile_id));

                // Create 96 cells (12 cols × 8 rows) using actual xtile/ytile coordinates
                for (let row = 0; row < gridLayout.rows; row++) {
                    for (let col = 0; col < gridLayout.cols; col++) {
                        const tile = data.find(
                            t => t.xtile === gridLayout.minX + col && t.ytile === gridLayout.minY + row
                        );
                        const cell = document.createElement('div');
                        cell.className = 'bucket-cell';

                        if (tile && tileIds.has(tile.tile_id)) {
                            // Tile is in this bucket
                            const f1 = tile.f1_score || 0;
                            const intensity = f1; // 0-1 range
                            cell.style.background = bucket.color;
                            cell.style.opacity = 0.3 + (intensity * 0.7);

                            // Tooltip
                            let tooltip = null;
                            cell.addEventListener('mouseenter', (e) => {
                                tooltip = document.createElement('div');
                                tooltip.style.position = 'fixed';
                                tooltip.style.left = `${e.clientX + 12}px`;
                                tooltip.style.top = `${e.clientY - 12}px`;
                                tooltip.style.background = 'rgba(0, 0, 0, 0.95)';
                                tooltip.style.color = '#fff';
                                tooltip.style.padding = '10px 14px';
                                tooltip.style.borderRadius = '6px';
                                tooltip.style.fontSize = '12px';
                                tooltip.style.zIndex = '10000';
                                tooltip.style.pointerEvents = 'none';
                                tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                                tooltip.style.border = `2px solid ${bucket.color}`;
                                tooltip.innerHTML = `
                                    <div style="font-weight: bold; margin-bottom: 4px; color: ${bucket.color};">Tile ${tile.tile_id}</div>
                                    <div>F1: ${(f1 * 100).toFixed(1)}%</div>
                                    <div>Precision: ${((tile.precision || 0) * 100).toFixed(1)}%</div>
                                    <div>Recall: ${((tile.recall || 0) * 100).toFixed(1)}%</div>
                                `;
                                document.body.appendChild(tooltip);
                            });

                            cell.addEventListener('mousemove', (e) => {
                                if (tooltip) {
                                    tooltip.style.left = `${e.clientX + 12}px`;
                                    tooltip.style.top = `${e.clientY - 12}px`;
                                }
                            });

                            cell.addEventListener('mouseleave', () => {
                                if (tooltip) {
                                    document.body.removeChild(tooltip);
                                    tooltip = null;
                                }
                            });
                        } else {
                            // Empty cell (tile not in this bucket)
                            cell.classList.add('empty');
                        }

                        grid.appendChild(cell);
                    }
                }

                card.appendChild(grid);

                // Create map container (initially hidden)
                const mapContainer = document.createElement('div');
                mapContainer.className = 'bucket-map-container';
                mapContainer.style.display = 'none';
                mapContainer.id = `bucket-map-${bucket.name.toLowerCase()}`;
                card.appendChild(mapContainer);

                // Add toggle event listeners
                if (bucket.tiles.length > 0) {
                    const gridBtn = card.querySelector('.bucket-toggle-btn:first-child');
                    const mapBtn = card.querySelector('.bucket-toggle-btn:last-child');
                    
                    gridBtn.addEventListener('click', () => {
                        grid.style.display = 'grid';
                        mapContainer.style.display = 'none';
                        gridBtn.classList.add('active');
                        mapBtn.classList.remove('active');
                    });
                    
                    mapBtn.addEventListener('click', () => {
                        grid.style.display = 'none';
                        mapContainer.style.display = 'block';
                        gridBtn.classList.remove('active');
                        mapBtn.classList.add('active');
                        
                        // Initialize map if not already done
                        if (!mapContainer.dataset.initialized) {
                            renderBucketMap(mapContainer, bucket, data);
                            mapContainer.dataset.initialized = 'true';
                        }
                    });
                }

                // Stats
                if (bucket.tiles.length > 0) {
                    const stats = document.createElement('div');
                    stats.className = 'bucket-stats';

                    const f1Stat = document.createElement('div');
                    f1Stat.className = 'bucket-stat';
                    f1Stat.innerHTML = `
                        <span class="bucket-stat-value">${(avgF1 * 100).toFixed(1)}%</span>
                        Avg F1
                    `;

                    const precisionStat = document.createElement('div');
                    precisionStat.className = 'bucket-stat';
                    precisionStat.innerHTML = `
                        <span class="bucket-stat-value">${(avgPrecision * 100).toFixed(1)}%</span>
                        Avg Precision
                    `;

                    const recallStat = document.createElement('div');
                    recallStat.className = 'bucket-stat';
                    recallStat.innerHTML = `
                        <span class="bucket-stat-value">${(avgRecall * 100).toFixed(1)}%</span>
                        Avg Recall
                    `;

                    stats.appendChild(f1Stat);
                    stats.appendChild(precisionStat);
                    stats.appendChild(recallStat);
                    card.appendChild(stats);
                }

                bucketsGrid.appendChild(card);
            });

            container.appendChild(bucketsGrid);
        }

        function renderTable(filteredData = data) {
            const sortKey = document.getElementById('sort-select').value;

            const sorted = [...filteredData]
                .sort((a, b) => (b[sortKey] || 0) - (a[sortKey] || 0));

            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            sorted.forEach((tile, idx) => {
                const row = document.createElement('tr');
                const isSelected = selectedTiles.has(tile.tile_id);
                
                row.style.cursor = 'pointer';
                row.title = `Click to select, Ctrl+Click for details`;
                if (isSelected) {
                    row.style.background = 'rgba(250, 204, 21, 0.2)';
                    row.style.borderLeft = '4px solid #facc15';
                }
                
                row.innerHTML = `
                    <td>${tile.tile_id}</td>
                    <td>${tile.xtile}, ${tile.ytile}</td>
                    <td><span class="metric-${tile.f1_score > 0.7 ? 'good' : tile.f1_score > 0.4 ? 'okay' : 'bad'}">
                        ${formatValue(tile.f1_score, true)}
                    </span></td>
                    <td>${formatValue(tile.precision, true)}</td>
                    <td>${formatValue(tile.recall, true)}</td>
                    <td>${formatValue(tile.iou, true)}</td>
                    <td><span class="metric-tp">${formatValue(tile.tp_length_m, false)}</span></td>
                    <td><span class="metric-fp">${formatValue(tile.fp_length_m, false)}</span></td>
                    <td><span class="metric-fn">${formatValue(tile.fn_length_m, false)}</span></td>
                `;
                
                // Click to select, Ctrl+Click to open modal
                row.addEventListener('click', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        openTileDetailModal(tile);
                    } else {
                        toggleTileSelection(tile.tile_id, e);
                    }
                });
                
                tbody.appendChild(row);
            });
        }

        function getFilteredData() {
            // Use global filterThreshold variable (0-100 scale)
            const threshold = filterThreshold / 100; // Convert 0-100 to 0-1
            return data.filter(tile => (tile.f1_score || 0) >= threshold);
        }

        let spatialMode = 'map'; // Track current spatial view mode
        let selectedTiles = new Set(); // Track selected tiles across all views

        function updateSelectionCount() {
            const count = selectedTiles.size;
            const sidebarCount = document.getElementById('selection-count-sidebar');
            if (sidebarCount) sidebarCount.textContent = count;
        }

        function clearSelection() {
            selectedTiles.clear();
            updateSelectionCount();
            render(); // Re-render to remove highlights
        }

        function toggleTileSelection(tileId) {
            if (selectedTiles.has(tileId)) {
                selectedTiles.delete(tileId);
            } else {
                selectedTiles.add(tileId);
            }
            updateSelectionCount();
            render(); // Re-render to update highlights across all views
        }

        function render() {
            // Don't render if data isn't loaded yet
            if (!data || data.length === 0) return;
            
            // Clean up all tooltips before rendering
            document.querySelectorAll('[id$="-tooltip"]').forEach(t => t.remove());
            
            const viewMode = document.getElementById('view-mode').value;
            const threshold = filterThreshold / 100; // Use global variable
            
            // Get filtered data
            const filteredData = getFilteredData();
            const filteredCount = filteredData.length;
            const totalCount = data.length;
            
            document.getElementById('spatial-section').style.display = viewMode === 'spatial' ? 'block' : 'none';
            document.getElementById('scatter-section').style.display = viewMode === 'scatter' ? 'block' : 'none';
            document.getElementById('parallel-section').style.display = viewMode === 'parallel' ? 'block' : 'none';
            document.getElementById('statistical-section').style.display = viewMode === 'statistical' ? 'block' : 'none';
            document.getElementById('erroranalysis-section').style.display = viewMode === 'erroranalysis' ? 'block' : 'none';
            document.getElementById('table-section').style.display = viewMode === 'table' ? 'block' : 'none';

            // Always render global confusion matrix (visible in all views) - use filtered data
            renderGlobalConfusionMatrix(filteredData);
            
            renderStats(filteredData);

            if (viewMode === 'spatial') {
                if (spatialMode === 'heatmap') {
                    renderHeatmap(filteredData);
                } else {
                    setTimeout(() => renderMap(filteredData), 100);
                }
            } else if (viewMode === 'scatter') {
                renderScatter(filteredData);
            } else if (viewMode === 'parallel') {
                setTimeout(() => renderParallelCoordinates(filteredData), 100);
            } else if (viewMode === 'statistical') {
                renderDistributions(filteredData);
                renderCorrelation(filteredData);
            } else if (viewMode === 'erroranalysis') {
                renderBuckets(filteredData);
                renderComposition(filteredData);
            } else if (viewMode === 'table') {
                renderTable(filteredData);
            }
        }

        // ==============================================
        // FEATURE #8: TILE DETAIL MODAL
        // ==============================================

        let detailMapInstance = null; // Global map instance for modal
        let isModalOpen = false; // Prevent multiple simultaneous modals

        /**
         * Opens the tile detail modal and populates it with tile data
         * @param {Object} tile - Tile object from data array
         */
        function openTileDetailModal(tile) {
            if (isModalOpen) return; // Prevent multiple opens
            isModalOpen = true;
            
            // 1. Populate modal title with action button
            document.getElementById('modal-title').innerHTML = `
                Tile #${tile.tile_id} (${tile.xtile}, ${tile.ytile})
                <button onclick="viewTileOnMap(${tile.tile_id})" style="
                    margin-left: 16px;
                    padding: 4px 12px;
                    background: #3b82f6;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                    transition: background 0.2s;
                " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
                    View on Map
                </button>
            `;
            
            // 2. Populate Section 1: Metric Cards
            populateMetricCards(tile);
            
            // 3. Populate Section 2: Confusion Matrix Details
            populateConfusionDetails(tile);
            
            // 4. Populate Section 3: Raw Data Table
            populateRawDataTable(tile);
            
            // 5. Show modal
            document.getElementById('tile-detail-backdrop').classList.add('visible');
            document.getElementById('tile-detail-modal').classList.add('visible');
            
            // 6. Initialize/update mini map (Feature #10)
            setTimeout(() => {
                initTileMiniMapIfNeeded();
                updateTileMiniMap(tile);
            }, 100); // Small delay to ensure modal is visible
        }

        /**
         * Closes the tile detail modal
         */
        function closeTileDetailModal() {
            document.getElementById('tile-detail-backdrop').classList.remove('visible');
            document.getElementById('tile-detail-modal').classList.remove('visible');
            isModalOpen = false;
        }

        /**
         * Switches to spatial map view and highlights the selected tile
         * @param {number} tileId - The tile ID to view
         */
        function viewTileOnMap(tileId) {
            // Close modal
            closeTileDetailModal();
            
            // Switch to spatial view
            document.getElementById('view-mode').value = 'spatial';
            
            // Ensure map view is active (not heatmap grid)
            spatialMode = 'map';
            document.getElementById('heatmap-view').style.display = 'none';
            document.getElementById('map-view').style.display = 'block';
            document.getElementById('toggle-map').style.background = '#3b82f6';
            document.getElementById('toggle-map').style.color = 'white';
            document.getElementById('toggle-heatmap').style.background = 'transparent';
            document.getElementById('toggle-heatmap').style.color = '#94a3b8';
            
            // Select the tile
            selectedTiles.clear();
            selectedTiles.add(tileId);
            
            // Re-render to show the tile
            render();
            
            // Zoom to tile on map if it exists
            setTimeout(() => {
                const tile = data.find(t => t.tile_id === tileId);
                if (tile && map) {
                    map.setView([tile.lat, tile.lon], 18);
                }
            }, 300);
        }

        /**
         * Populates the metric summary cards
         */
        function populateMetricCards(tile) {
            const container = document.getElementById('modal-metrics');
            container.innerHTML = `
                <h3>Performance Metrics</h3>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                ${createMetricCard('F1 Score', tile.f1_score, true)}
                ${createMetricCard('Precision', tile.precision, true)}
                ${createMetricCard('Recall', tile.recall, true)}
                ${createMetricCard('IoU', tile.iou, true)}
                </div>
            `;
        }

        /**
         * Helper to create a metric card HTML
         */
        function createMetricCard(label, value, isPercentage) {
            const displayValue = isPercentage 
                ? `${(value * 100).toFixed(1)}%` 
                : `${value.toFixed(2)}m`;
            
            // Color coding based on value
            let color = '#94a3b8';
            if (isPercentage) {
                if (value >= 0.9) color = '#10b981'; // Green
                else if (value >= 0.7) color = '#3b82f6'; // Blue
                else if (value >= 0.5) color = '#f59e0b'; // Orange
                else color = '#ef4444'; // Red
            }
            
            return `
                <div style="background: rgba(15,23,42,0.5); padding: 16px; border-radius: 6px; border: 2px solid ${color}20;">
                <div style="font-size: 11px; color: #94a3b8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">${label}</div>
                <div style="font-size: 24px; font-weight: bold; color: ${color};">${displayValue}</div>
                </div>
            `;
        }

        /**
         * Populates confusion matrix details
         */
        function populateConfusionDetails(tile) {
            const container = document.getElementById('modal-confusion');
            container.innerHTML = `
                <h3>Confusion Matrix Breakdown</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4 style="color: #10b981; margin-bottom: 12px;">📏 Lengths (meters)</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(16,185,129,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">True Positive:</span>
                        <strong style="color: #10b981;">${tile.tp_length_m.toFixed(2)}m</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(239,68,68,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">False Positive:</span>
                        <strong style="color: #ef4444;">${tile.fp_length_m.toFixed(2)}m</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(245,158,11,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">False Negative:</span>
                        <strong style="color: #f59e0b;">${tile.fn_length_m.toFixed(2)}m</strong>
                    </div>
                    </div>
                </div>
                <div>
                    <h4 style="color: #3b82f6; margin-bottom: 12px;">🔢 Counts (segments)</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(16,185,129,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">TP Segments:</span>
                        <strong style="color: #10b981;">${tile.tp_count}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(239,68,68,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">FP Segments:</span>
                        <strong style="color: #ef4444;">${tile.fp_count}</strong>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(245,158,11,0.1); border-radius: 4px;">
                        <span style="color: #94a3b8;">FN Segments:</span>
                        <strong style="color: #f59e0b;">${tile.fn_count}</strong>
                    </div>
                    </div>
                </div>
                </div>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                    <span style="color: #94a3b8; font-size: 13px;">ML Total:</span>
                    <strong style="margin-left: 8px; color: #60a5fa;">${tile.ml_total_length_m.toFixed(2)}m (${tile.ml_count} segs)</strong>
                    </div>
                    <div>
                    <span style="color: #94a3b8; font-size: 13px;">OSM Total:</span>
                    <strong style="margin-left: 8px; color: #a78bfa;">${tile.osm_total_length_m.toFixed(2)}m (${tile.osm_count} segs)</strong>
                    </div>
                </div>
                </div>
            `;
        }

        /**
         * Populates raw data table with all fields
         */
        function populateRawDataTable(tile) {
            const container = document.getElementById('modal-raw-data');
            const fields = [
                ['Tile ID', tile.tile_id],
                ['Grid Position', `(${tile.xtile}, ${tile.ytile})`],
                ['Coordinates', `${tile.lat.toFixed(6)}°N, ${tile.lon.toFixed(6)}°W`],
                ['ML Total Length', `${tile.ml_total_length_m.toFixed(2)}m`],
                ['OSM Total Length', `${tile.osm_total_length_m.toFixed(2)}m`],
                ['ML Segment Count', tile.ml_count],
                ['OSM Segment Count', tile.osm_count],
                ['Buffer Distance', `${tile.buffer_distance_m}m`],
                ['Alignment Threshold', `${tile.alignment_angle_threshold_deg}°`]
            ];
            
            container.innerHTML = `
                <h3>Complete Tile Information</h3>
                <table style="width: 100%; border-collapse: collapse;">
                ${fields.map(([key, val]) => `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.08);">
                    <td style="padding: 10px 12px; color: #94a3b8; font-size: 13px;">${key}</td>
                    <td style="padding: 10px 12px; font-weight: 500; color: #e2e8f0; text-align: right;">${val}</td>
                    </tr>
                `).join('')}
                </table>
            `;
        }

        // ==============================================
        // FEATURE #10: MINI LEAFLET MAP IN MODAL
        // ==============================================

        /**
         * Initializes the Leaflet map inside the modal (only once)
         */
        function initTileMiniMapIfNeeded() {
            if (detailMapInstance) return; // Already initialized
            
            const container = document.getElementById('tile-mini-map');
            if (!container) {
                console.error('tile-mini-map container not found');
                return;
            }
            
            // Show loading indicator
            container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #94a3b8;"><div style="text-align: center;"><div>Loading map...</div></div></div>';
            
            try {
                // Create Leaflet map
                detailMapInstance = L.map('tile-mini-map').setView([42.355, -71.071], 17);
                
                // Add OSM tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(detailMapInstance);
                
                console.log('Mini map initialized successfully');
            } catch (error) {
                console.error('Failed to initialize mini map:', error);
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444;"><div style="text-align: center;"><div>Map failed to load</div></div></div>';
            }
        }

        /**
         * Updates the mini map to show the selected tile
         * @param {Object} tile - Tile object with lat/lon
         */
        function updateTileMiniMap(tile) {
            if (!detailMapInstance) {
                console.warn('Map not initialized, initializing now...');
                initTileMiniMapIfNeeded();
                if (!detailMapInstance) return;
            }
            
            // Clear existing layers (markers, rectangles) but keep base tiles
            detailMapInstance.eachLayer(layer => {
                if (layer instanceof L.Marker || layer instanceof L.Rectangle || layer instanceof L.Circle) {
                    detailMapInstance.removeLayer(layer);
                }
            });
            
            // Center map on tile
            detailMapInstance.setView([tile.lat, tile.lon], 18);
            
            // Add marker at tile center
            const marker = L.marker([tile.lat, tile.lon], {
                icon: L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34]
                })
            }).addTo(detailMapInstance);
            
            marker.bindPopup(`
                <div style="font-family: sans-serif;">
                <strong style="color: #3b82f6; font-size: 14px;">Tile ${tile.tile_id}</strong><br>
                <div style="margin-top: 8px; font-size: 12px; line-height: 1.6;">
                    <div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #e2e8f0;">
                        <strong>Performance:</strong> F1 ${(tile.f1_score * 100).toFixed(1)}%
                    </div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 8px;">
                        <strong>Position:</strong> <span>(${tile.xtile}, ${tile.ytile})</span>
                        <strong>Coords:</strong> <span>${tile.lat.toFixed(5)}°, ${tile.lon.toFixed(5)}°</span>
                        <strong>ML Total:</strong> <span>${tile.ml_total_length_m.toFixed(1)}m</span>
                        <strong>OSM Total:</strong> <span>${tile.osm_total_length_m.toFixed(1)}m</span>
                    </div>
                </div>
                </div>
            `).openPopup();
            
            // Draw approximate tile bounds
            const tileSize = (360 / Math.pow(2, 19)) * Math.cos(tile.lat * Math.PI / 180);
            const bounds = [
                [tile.lat - tileSize/2, tile.lon - tileSize/2],
                [tile.lat + tileSize/2, tile.lon + tileSize/2]
            ];
            
            // Get color based on F1 score
            const f1 = tile.f1_score;
            let color = '#ef4444'; // Red
            if (f1 >= 0.9) color = '#10b981'; // Green
            else if (f1 >= 0.7) color = '#3b82f6'; // Blue
            else if (f1 >= 0.5) color = '#f59e0b'; // Orange
            
            L.rectangle(bounds, {
                color: color,
                weight: 3,
                fillColor: color,
                fillOpacity: 0.15,
                dashArray: '5, 5'
            }).addTo(detailMapInstance);
            
            // Force map to redraw
            setTimeout(() => {
                if (detailMapInstance) {
                    detailMapInstance.invalidateSize();
                }
            }, 50);
            
            console.log(`Map updated for tile ${tile.tile_id} at (${tile.lat}, ${tile.lon})`);
        }

        // Event listeners
        document.getElementById('view-mode').addEventListener('change', render);
        
        document.getElementById('metric-select').addEventListener('change', render);
        
        document.getElementById('sort-select').addEventListener('change', () => {
            const viewMode = document.getElementById('view-mode').value;
            if (viewMode === 'table') render();
        });

        // Sync sidebar slider with main filter threshold (keeping for compatibility)
        const filterThresholdInput = document.getElementById('filter-threshold');
        const filterThresholdSidebar = document.getElementById('filter-threshold-sidebar');
        const thresholdValueSidebar = document.getElementById('threshold-value-sidebar');
        const thresholdInfoSidebar = document.getElementById('threshold-info-sidebar');
        const selectionCountSidebar = document.getElementById('selection-count-sidebar');
        
        // Update sidebar when main slider changes (or vice versa)
        function updateFilterThreshold(value) {
            filterThreshold = value; // Update the global variable
            if (filterThresholdInput) filterThresholdInput.value = value;
            if (filterThresholdSidebar) filterThresholdSidebar.value = value;
            if (thresholdValueSidebar) thresholdValueSidebar.textContent = `${value}%`;
            
            // Update tile count info
            if (data && thresholdInfoSidebar) {
                const threshold = value / 100;
                const filtered = data.filter(d => (d.f1_score || 0) >= threshold);
                thresholdInfoSidebar.textContent = `≥ ${value}% (${filtered.length}/${data.length} tiles)`;
            }
            
            render(); // Re-render everything with new threshold
        }
        
        if (filterThresholdInput) {
            filterThresholdInput.addEventListener('input', (e) => {
                updateFilterThreshold(e.target.value);
            });
        }
        
        if (filterThresholdSidebar) {
            filterThresholdSidebar.addEventListener('input', (e) => {
                updateFilterThreshold(e.target.value);
            });
        }

        // Toggle buttons for spatial view
        document.getElementById('toggle-heatmap').addEventListener('click', () => {
            spatialMode = 'heatmap';
            document.getElementById('heatmap-view').style.display = 'block';
            document.getElementById('map-view').style.display = 'none';
            document.getElementById('toggle-heatmap').style.background = '#3b82f6';
            document.getElementById('toggle-heatmap').style.color = 'white';
            document.getElementById('toggle-map').style.background = 'transparent';
            document.getElementById('toggle-map').style.color = '#94a3b8';
            render();
        });

        document.getElementById('toggle-map').addEventListener('click', () => {
            spatialMode = 'map';
            document.getElementById('heatmap-view').style.display = 'none';
            document.getElementById('map-view').style.display = 'block';
            document.getElementById('toggle-map').style.background = '#3b82f6';
            document.getElementById('toggle-map').style.color = 'white';
            document.getElementById('toggle-heatmap').style.background = 'transparent';
            document.getElementById('toggle-heatmap').style.color = '#94a3b8';
            render();
        });

        // ==============================================
        // MODAL CLOSE HANDLERS
        // ==============================================

        // Close modal on backdrop click
        document.getElementById('tile-detail-backdrop').addEventListener('click', closeTileDetailModal);

        // Close modal on X button click
        document.getElementById('modal-close-btn').addEventListener('click', closeTileDetailModal);

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isModalOpen) {
                closeTileDetailModal();
            }
        });

        // Keyboard shortcuts for tile navigation
        document.addEventListener('keydown', (e) => {
            // Only respond if modal is closed and a tile is selected
            if (isModalOpen || selectedTiles.size !== 1) return;
            
            const currentTileId = Array.from(selectedTiles)[0];
            const currentTile = data.find(t => t.tile_id === currentTileId);
            if (!currentTile) return;
            
            let nextTile = null;
            
            // Arrow key navigation based on grid position
            if (e.key === 'ArrowUp') {
                // Move north (decrease ytile)
                nextTile = data.find(t => t.xtile === currentTile.xtile && t.ytile === currentTile.ytile - 1);
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                // Move south (increase ytile)
                nextTile = data.find(t => t.xtile === currentTile.xtile && t.ytile === currentTile.ytile + 1);
                e.preventDefault();
            } else if (e.key === 'ArrowLeft') {
                // Move west (decrease xtile)
                nextTile = data.find(t => t.xtile === currentTile.xtile - 1 && t.ytile === currentTile.ytile);
                e.preventDefault();
            } else if (e.key === 'ArrowRight') {
                // Move east (increase xtile)
                nextTile = data.find(t => t.xtile === currentTile.xtile + 1 && t.ytile === currentTile.ytile);
                e.preventDefault();
            } else if (e.key === 'Enter' || e.key === ' ') {
                // Open modal for current tile
                openTileDetailModal(currentTile);
                e.preventDefault();
                return;
            }
            
            // If valid neighbor tile found, select it
            if (nextTile) {
                selectedTiles.clear();
                selectedTiles.add(nextTile.tile_id);
                render();
                
                // If in map view, center on new tile
                if (document.getElementById('view-mode').value === 'spatial' && spatialMode === 'map' && map) {
                    map.setView([nextTile.lat, nextTile.lon], map.getZoom());
                }
            }
        });

        // Initialize
        loadData();
    </script>
</body>
</html>